<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#1c2526" />
  <link rel="manifest" href="/manifest.json" />
  <title>Arbo Editor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codicon/0.0.8/codicon.min.css" />
  <style>
    /* CSS Variables for easier theme and spacing management */
    :root {
      --bg-primary: #1e1e1e;
      --bg-secondary: #252526;
      --bg-tertiary: #333333;
      --text-color: #cccccc;
      --border-color: #444444;
      --accent-color: #007acc;
      --accent-hover-color: #005f99;
      --button-hover-bg: #555555;
      --button-active-scale: 0.98;
      --transition-speed: 0.2s;
      --toast-success: #4CAF50;
      --toast-error: #f44336;
      --toast-info: #2196F3;
      --toolbar-height: 36px; /* Approx height, updated dynamically by JS */
      --status-bar-height: 32px; /* Approx height, updated dynamically by JS */

      /* Base font size for the entire app, influencing all 'em' units */
      font-size: 10px; /* Base font size for overall smaller UI */
    }

    /* Light Theme Variables */
    body.vs-light {
      --bg-primary: #ffffff;
      --bg-secondary: #f3f3f3;
      --bg-tertiary: #e6e6e6;
      --text-color: #333333;
      --border-color: #cccccc;
      --button-hover-bg: #dddddd;
    }

    /* Basic Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      overflow: hidden; /* Prevent body scroll, handled by individual containers */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-primary);
      color: var(--text-color);
      line-height: 1.5; /* Improved readability */
    }

    #app {
      display: flex;
      height: 100%;
      opacity: 0; /* Initially hidden, show after editor loads */
      transition: opacity 0.3s ease-in-out;
      overflow: hidden; /* Ensure app itself doesn't cause unexpected scrolls */
    }

    #app.loaded {
      opacity: 1;
    }

    /* Loading Spinner */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-primary);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      opacity: 1;
      transition: opacity 0.3s ease-in-out;
    }

    #loading-overlay.hidden {
      opacity: 0;
      pointer-events: none; /* Allow interaction with content underneath */
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid var(--accent-color);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Sidebar */
    #sidebar {
      width: 50px; /* Smaller sidebar width */
      background: var(--bg-tertiary);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 0.5em; /* Reduced padding */
      border-right: 1px solid var(--border-color);
      overflow-y: auto; /* Allow sidebar to scroll */
      flex-shrink: 0;
      transition: width var(--transition-speed) ease, transform var(--transition-speed) ease;
    }

    #sidebar.collapsed {
        width: 0;
        padding-left: 0;
        padding-right: 0;
        border-right: none;
        overflow: hidden; /* Hide content when collapsed */
    }

    #sidebar button, #sidebar select {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      padding: 0.8em; /* Relative padding */
      width: 100%;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4em;
      margin-bottom: 0.3em;
      border-radius: 4px;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, transform 0.1s ease;
    }

    #sidebar button:hover, #sidebar select:hover {
      background: var(--button-hover-bg);
      color: #ffffff; /* White text on hover for contrast */
      transform: scale(1.02);
    }

    #sidebar button:active {
      transform: scale(var(--button-active-scale));
    }

    #sidebar button.active {
      background: var(--accent-color);
      color: #ffffff;
    }

    #sidebar button .codicon, #sidebar select .codicon {
      font-size: 1.8em;
      transition: transform var(--transition-speed) ease;
    }

    #sidebar select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      padding: 0.3em 0;
      font-size: 1.2em;
      color: var(--text-color);
      text-align-last: center;
      transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
      position: relative;
    }

    #sidebar select:hover {
      border-color: var(--accent-color);
    }

    #sidebar select option {
      background-color: var(--bg-tertiary);
      color: var(--text-color);
    }

    #font-size-select-wrapper, #language-select-wrapper {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.3em;
    }

    #font-size-select-wrapper .codicon, #language-select-wrapper .codicon {
      position: absolute;
      left: 0.5em;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5em;
      color: var(--text-color);
      pointer-events: none;
    }

    #font-size-select, #language-select {
      padding-left: 2.5em; /* Adjusted for icon */
      width: 100%;
      height: 3em; /* Relative height */
    }

    /* Horizontal Rule in Sidebar */
    #sidebar hr {
      width: 80%;
      border: 0;
      border-top: 1px solid var(--border-color);
      margin: 0.5em 0;
    }

    /* Editor Container */
    #editor-container {
      flex: 1;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      transition: all var(--transition-speed) ease;
      position: relative; /* For read-only overlay */
    }

    /* Maximized state for editor-container */
    #app.maximized-editor #editor-container {
      position: fixed; /* Use fixed for true full screen */
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 100;
      margin-left: 0;
    }

    /* Top Toolbar for Editor */
    #editor-toolbar {
      background: var(--bg-secondary);
      padding: 0.3em 0.8em;
      display: flex;
      gap: 0.5em;
      border-bottom: 1px solid var(--border-color);
      align-items: center;
      flex-shrink: 0;
      height: var(--toolbar-height); /* Ensure fixed height for calculation */
    }

    #editor-toolbar button {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      padding: 0.3em 0.6em;
      font-size: 1.3em;
      border-radius: 4px;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #editor-toolbar button:hover {
      background: var(--button-hover-bg);
      color: #ffffff;
    }

    #editor-toolbar button .codicon {
      font-size: 1.6em;
    }

    /* Monaco Editor Wrapper */
    #container {
      flex: 1;
      width: 100%;
      transition: opacity 0.3s ease;
    }

    /* Read-Only Overlay */
    .read-only-overlay {
      position: absolute;
      top: var(--toolbar-height);
      left: 0;
      width: 100%;
      height: calc(100% - var(--toolbar-height) - var(--status-bar-height));
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 2em;
      font-weight: bold;
      z-index: 50;
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--transition-speed) ease-in-out;
    }

    .read-only-overlay.visible {
      opacity: 1;
    }

    /* Status Bar */
    #status-bar {
      background: var(--accent-color);
      color: #ffffff;
      padding: 0.4em 0.8em;
      font-size: 1.1em;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1em;
      flex-shrink: 0;
      transition: background-color var(--transition-speed) ease;
      height: var(--status-bar-height); /* Ensure fixed height for calculation */
    }

    #status-bar span {
      display: flex;
      align-items: center;
      gap: 0.3em;
      transition: color var(--transition-speed) ease;
    }

    .codicon {
      font-family: 'codicon';
      font-size: 1em; /* Base icon size relative to parent font size */
      transition: color var(--transition-speed) ease;
    }

    /* Custom Context Menu */
    #custom-context-menu {
      position: absolute;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
      padding: 0.3em 0;
      opacity: 0;
      transform: scale(0.95);
      transform-origin: top left;
      transition: opacity 0.15s ease-out, transform 0.15s ease-out;
    }

    #custom-context-menu.show {
      display: block;
      opacity: 1;
      transform: scale(1);
    }

    #custom-context-menu button {
      background: none;
      border: none;
      color: var(--text-color);
      padding: 0.6em 1em;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 1.2em;
      display: flex;
      align-items: center;
      gap: 0.5em;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
    }

    #custom-context-menu button:hover, #custom-context-menu button:focus {
      background: var(--accent-color);
      color: #ffffff;
      outline: none;
    }

    #custom-context-menu button:disabled {
      color: #777777;
      cursor: not-allowed;
      background: none;
      opacity: 0.6;
    }

    /* Toast Notification */
    .toast {
      visibility: hidden;
      min-width: 20em;
      background-color: var(--bg-tertiary);
      color: #fff;
      text-align: center;
      border-radius: 4px;
      padding: 0.8em 1.2em;
      position: fixed;
      z-index: 1001;
      left: 50%;
      transform: translateX(-50%) translateY(1.5em);
      bottom: 2em;
      font-size: 1.2em;
      opacity: 0;
      transition: opacity var(--transition-speed) ease-out, transform var(--transition-speed) ease-out, background-color var(--transition-speed) ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .toast.show {
      visibility: visible;
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast.success { background-color: var(--toast-success); }
    .toast.error { background-color: var(--toast-error); }
    .toast.info { background-color: var(--toast-info); }

    /* Key Logging Display */
    #key-logging-display {
      background-color: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 0.4em 0.8em;
      border-radius: 4px;
      font-size: 0.9em;
      position: absolute;
      bottom: 0.3em;
      right: 0.3em;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.1s ease-in-out;
      pointer-events: none;
      display: none; /* Hidden by default */
      min-width: unset; /* Override toast min-width */
      transform: none; /* Override toast transform */
    }

    #key-logging-display.show-key-log {
      opacity: 1;
      display: block;
    }

    /* Diff View Styles */
    #diff-container {
      display: none;
      flex-direction: column;
      height: 100%;
      width: 100%;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      flex: 1;
    }

    #diff-container.show {
        display: flex;
        opacity: 1;
    }

    #diff-toolbar {
      background: var(--bg-secondary);
      padding: 0.5em 0.8em;
      display: flex;
      gap: 0.8em;
      border-bottom: 1px solid var(--border-color);
      align-items: center;
      justify-content: flex-end;
      flex-shrink: 0;
      transition: background-color var(--transition-speed) ease;
    }

    #diff-toolbar button {
      background: var(--accent-color);
      color: #ffffff;
      border: none;
      padding: 0.4em 0.8em;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.2em;
      display: flex;
      align-items: center;
      gap: 0.3em;
      transition: background-color var(--transition-speed) ease, transform 0.1s ease;
    }

    #diff-toolbar button:hover {
      background: var(--accent-hover-color);
      transform: scale(1.02);
    }

    #diff-toolbar button:active {
      transform: scale(var(--button-active-scale));
    }

    #diff-editor {
      flex: 1;
      width: 100%;
    }

    /* Custom Modal Styles */
    .custom-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1002;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }

    .custom-modal-overlay.visible {
        opacity: 1;
        visibility: visible;
    }

    .custom-modal {
        background: var(--bg-secondary);
        padding: 1.5em;
        border-radius: 6px;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
        max-width: 35em;
        width: 85%;
        color: var(--text-color);
        transform: translateY(-1.5em);
        transition: transform 0.3s ease-in-out;
    }

    .custom-modal-overlay.visible .custom-modal {
        transform: translateY(0);
    }

    .custom-modal h3 {
        margin-top: 0;
        color: #e0e0e0;
        font-size: 1.2em;
        margin-bottom: 1em;
    }

    .custom-modal p {
        margin-bottom: 1.5em;
        line-height: 1.4;
        font-size: 0.9em;
    }

    .custom-modal input[type="text"] {
        width: 100%;
        padding: 0.8em;
        margin-bottom: 1.5em;
        border: 1px solid var(--border-color);
        background-color: var(--bg-tertiary);
        color: var(--text-color);
        border-radius: 4px;
        font-size: 1em;
    }

    .custom-modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 0.8em;
    }

    .custom-modal-buttons button {
        padding: 0.6em 1.2em;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color var(--transition-speed) ease, transform 0.1s ease;
    }

    .custom-modal-buttons button.confirm-btn {
        background-color: var(--accent-color);
        color: #ffffff;
    }

    .custom-modal-buttons button.confirm-btn:hover {
        background-color: var(--accent-hover-color);
        transform: scale(1.02);
    }

    .custom-modal-buttons button.cancel-btn {
        background-color: #555555;
        color: #ffffff;
    }

    .custom-modal-buttons button.cancel-btn:hover {
        background-color: #666666;
        transform: scale(1.02);
    }

    /* Responsive Design - Fluid adjustments for desktop-like feel on smaller screens */
    @media (max-width: 768px) {
        :root {
            font-size: 9px; /* Slightly smaller base font for tablets */
        }
        #sidebar {
            width: 55px;
        }
        #sidebar button, #sidebar select {
            padding: 0.6em;
            font-size: 1.3em;
        }
        #sidebar button .codicon, #sidebar select .codicon {
            font-size: 1.6em;
        }
        #font-size-select, #language-select {
          padding-left: 2em;
          height: 3.5em;
        }
        #editor-toolbar {
            padding: 0.4em 0.6em;
            gap: 0.6em;
        }
        #editor-toolbar button {
            font-size: 1.2em;
            padding: 0.4em 0.6em;
        }
        #editor-toolbar button .codicon {
            font-size: 1.5em;
        }
        #status-bar {
            font-size: 1em;
            padding: 0.4em 0.6em;
            gap: 0.6em;
        }
        .toast {
            min-width: 90%;
            left: 5%;
            transform: translateX(0%) translateY(2em); /* Remove horizontal transform for mobile */
            bottom: 2em;
            font-size: 1.2em;
        }
        .toast.show {
            transform: translateX(0%) translateY(0);
        }
        .custom-modal {
            max-width: 90%; /* Increase modal width on smaller screens */
            padding: 1.8em;
        }
    }

    @media (max-width: 480px) {
        :root {
            font-size: 8px; /* Even smaller base font for mobile */
        }
        #sidebar {
            width: 45px;
        }
        #sidebar button, #sidebar select {
            padding: 0.5em;
            font-size: 1.2em;
        }
        #sidebar button .codicon, #sidebar select .codicon {
            font-size: 1.4em;
        }
        #font-size-select, #language-select {
          padding-left: 1.8em;
          height: 3em;
        }
        #editor-toolbar {
            padding: 0.3em 0.4em;
            gap: 0.4em;
        }
        #editor-toolbar button {
            font-size: 1.1em;
            padding: 0.3em 0.5em;
        }
        #editor-toolbar button .codicon {
            font-size: 1.3em;
        }
        #status-bar {
            font-size: 0.9em;
            padding: 0.3em 0.4em;
            gap: 0.4em;
        }
        .toast {
            bottom: 1.5em;
            font-size: 1em;
        }
        .custom-modal {
            padding: 1.2em;
        }
    }
  </style>
</head>
<body class="vs-dark">
  <div id="loading-overlay">
    <div class="spinner"></div>
  </div>

  <div id="app">
    <aside id="sidebar" role="navigation" aria-label="Editor Tools">
      <button id="new-file-btn" title="New File" aria-label="Create New File">
        <span class="codicon codicon-new-file"></span>
      </button>
      <button id="open-file-btn" title="Open File" aria-label="Open File from Device">
        <span class="codicon codicon-folder-opened"></span>
      </button>
      <button id="save-cache-btn" title="Save to Cache" aria-label="Save Current Content to Cache">
        <span class="codicon codicon-save"></span>
      </button>
      <button id="download-btn" title="Download Code" aria-label="Download Code to File">
        <span class="codicon codicon-cloud-download"></span>
      </button>
      <div class="sidebar-separator"></div>
      <div id="language-select-wrapper">
        <span class="codicon codicon-file-code" aria-hidden="true"></span>
        <label for="language-select" class="sr-only">Select Programming Language</label>
        <select id="language-select" title="Select Language" aria-label="Select Programming Language">
          <option value="javascript">JS</option>
          <option value="typescript">TS</option>
          <option value="html">HTML</option>
          <option value="css">CSS</option>
          <option value="json">JSON</option>
          <option value="python">PY</option>
          <option value="java">Java</option>
          <option value="csharp">C#</option>
          <option value="php">PHP</option>
          <option value="markdown">MD</option>
          <option value="xml">XML</option>
          <option value="ruby">Ruby</option>
          <option value="go">Go</option>
          <option value="swift">Swift</option>
          <option value="kotlin">Kotlin</option>
          <option value="rust">Rust</option>
          <option value="sql">SQL</option>
          <option value="yaml">YAML</option>
          <option value="toml">TOML</option>
          <option value="powershell">PS</option>
          <option value="dockerfile">Docker</option>
          <option value="cpp">C++</option>
          <option value="c">C</option>
          <option value="objective-c">Obj-C</option>
          <option value="perl">Perl</option>
          <option value="r">R</option>
          <option value="shell">Shell</option>
          <option value="plaintext">Text</option>
        </select>
      </div>
      <div id="font-size-select-wrapper">
        <span class="codicon codicon-text-size" aria-hidden="true"></span>
        <label for="font-size-select" class="sr-only">Select Font Size</label>
        <select id="font-size-select" title="Font Size" aria-label="Select Editor Font Size">
          <option value="7">7px</option>
          <option value="9">9px</option>
          <option value="10" selected>10px</option>
          <option value="12">12px</option>
          <option value="14">14px</option>
          <option value="16">16px</option>
          <option value="18">18px</option>
          <option value="20">20px</option>
          <option value="24">24px</option>
        </select>
      </div>
      <div class="sidebar-separator"></div>
      <button id="copy-all-btn" title="Copy All Code" aria-label="Copy All Editor Content">
        <span class="codicon codicon-copy"></span>
      </button>
      <button id="format-code-btn" title="Format Code" aria-label="Format Document Code">
        <span class="codicon codicon-symbol-ruler"></span>
      </button>
      <div class="sidebar-separator"></div>
      <button id="find-replace-btn" title="Find/Replace" aria-label="Open Find and Replace Panel">
        <span class="codicon codicon-search"></span>
      </button>
      <button id="toggle-word-wrap-btn" title="Toggle Word Wrap" aria-label="Toggle Word Wrap">
        <span class="codicon codicon-word-wrap"></span>
      </button>
      <button id="diff-view-btn" title="Compare with Original" aria-label="Compare Current Code with Saved Original">
        <span class="codicon codicon-diff"></span>
      </button>
      <button id="theme-toggle-btn" title="Toggle Theme" aria-label="Toggle Editor Color Theme (Dark/Light)">
        <span class="codicon codicon-lightbulb"></span>
      </button>
      <div class="sidebar-separator"></div>
      <button id="toggle-minimap-btn" title="Toggle Minimap" aria-label="Toggle Code Minimap">
        <span class="codicon codicon-map"></span>
      </button>
      <button id="toggle-line-numbers-btn" title="Toggle Line Numbers" aria-label="Toggle Display of Line Numbers">
        <span class="codicon codicon-list-ordered"></span>
      </button>
      <button id="read-only-mode-btn" title="Toggle Read-Only Mode" aria-label="Toggle Editor Read-Only Mode">
        <span class="codicon codicon-lock"></span>
      </button>
      <button id="clear-editor-btn" title="Clear Editor" aria-label="Clear All Editor Content">
        <span class="codicon codicon-clear-all"></span>
      </button>
    </aside>
    <main id="editor-container" role="main" aria-label="Code Editor">
      <header id="editor-toolbar" role="toolbar" aria-label="Editor Actions">
        <button id="toggle-sidebar-btn" title="Toggle Sidebar" aria-label="Toggle Navigation Sidebar">
            <span class="codicon codicon-three-bars"></span>
        </button>
        <button id="undo-btn" title="Undo" aria-label="Undo Last Action">
          <span class="codicon codicon-arrow-left"></span>
        </button>
        <button id="redo-btn" title="Redo" aria-label="Redo Last Action">
          <span class="codicon codicon-arrow-right"></span>
        </button>
        <div style="flex-grow: 1;"></div>
        <button id="maximize-minimize-btn" title="Toggle Fullscreen" aria-label="Toggle Editor Fullscreen Mode">
          <span class="codicon codicon-screen-full"></span>
        </button>
        <button id="cursor-up-btn" title="Move Cursor Up" aria-label="Move Cursor Up">
            <span class="codicon codicon-arrow-up"></span>
        </button>
        <button id="cursor-down-btn" title="Move Cursor Down" aria-label="Move Cursor Down">
            <span class="codicon codicon-arrow-down"></span>
        </button>
        <button id="cursor-left-btn" title="Move Cursor Left" aria-label="Move Cursor Left">
            <span class="codicon codicon-arrow-left"></span>
        </button>
        <button id="cursor-right-btn" title="Move Cursor Right" aria-label="Move Cursor Right">
            <span class="codicon codicon-arrow-right"></span>
        </button>
      </header>
      <div id="container" role="code" aria-multiline="true"></div>
      <div class="read-only-overlay" id="read-only-overlay">
        <span class="codicon codicon-lock" aria-hidden="true"></span> READ-ONLY
      </div>
      <footer id="status-bar" role="contentinfo">
        <span id="lang-display-wrapper"><span class="codicon codicon-symbol-text" aria-hidden="true"></span> <span id="lang-display" aria-live="polite">javascript</span></span>
        <span id="cursor-pos-wrapper"><span class="codicon codicon-pencil" aria-hidden="true"></span> <span id="cursor-pos" aria-live="polite">Ln 1, Col 1</span></span>
        <span id="word-char-count" aria-live="polite"><span class="codicon codicon-text-size" aria-hidden="true"></span> Words: 0 | Chars: 0</span>
        <span id="error-status" style="color: var(--toast-error); margin-left: auto; display: none;" aria-live="polite" role="status"><span class="codicon codicon-error" aria-hidden="true"></span> Errors: 0</span>
      </footer>
      <div id="key-logging-display" class="key-log-toast" role="status" aria-live="polite"></div>
    </main>
    <div id="diff-container" role="dialog" aria-label="Code Comparison View">
      <div id="diff-toolbar" role="toolbar" aria-label="Diff View Actions">
        <button id="close-diff-btn" title="Close Diff View" aria-label="Close Code Comparison View">
          <span class="codicon codicon-close" aria-hidden="true"></span> Close Diff
        </button>
        <button id="accept-changes-btn" title="Accept Changes" aria-label="Accept Changes from Diff View">
          <span class="codicon codicon-check" aria-hidden="true"></span> Accept Changes
        </button>
      </div>
      <div id="diff-editor" role="code" aria-multiline="true" aria-label="Original vs Modified Code"></div>
    </div>
  </div>
  <div id="custom-context-menu" role="menu" aria-hidden="true">
    <button id="context-copy-btn" role="menuitem" aria-label="Copy Selected Text"><span class="codicon codicon-copy" aria-hidden="true"></span> Copy</button>
    <button id="context-paste-btn" role="menuitem" aria-label="Paste Text"><span class="codicon codicon-paste" aria-hidden="true"></span> Paste</button>
    <button id="context-cut-btn" role="menuitem" aria-label="Cut Selected Text"><span class="codicon codicon-cut" aria-hidden="true"></span> Cut</button>
    <div class="context-menu-separator"></div>
    <button id="context-format-btn" role="menuitem" aria-label="Format Selection or Document"><span class="codicon codicon-symbol-ruler" aria-hidden="true"></span> Format Selection</button>
    <div class="context-menu-separator"></div>
    <button id="context-select-all-btn" role="menuitem" aria-label="Select All Text"><span class="codicon codicon-whole-word" aria-hidden="true"></span> Select All</button>
  </div>
  <div id="toast-message" class="toast" role="alert" aria-live="assertive"></div>

  <div id="custom-alert-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog" aria-labelledby="alert-modal-title">
    <div class="custom-modal">
      <h3 id="alert-modal-title"></h3>
      <p id="alert-modal-message"></p>
      <div class="custom-modal-buttons">
        <button class="confirm-btn" id="alert-modal-ok-btn">OK</button>
      </div>
    </div>
  </div>

  <div id="custom-confirm-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog" aria-labelledby="confirm-modal-title">
    <div class="custom-modal">
      <h3 id="confirm-modal-title"></h3>
      <p id="confirm-modal-message"></p>
      <div class="custom-modal-buttons">
        <button class="cancel-btn" id="confirm-modal-cancel-btn">Cancel</button>
        <button class="confirm-btn" id="confirm-modal-confirm-btn">Confirm</button>
      </div>
    </div>
  </div>

  <div id="custom-prompt-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog" aria-labelledby="prompt-modal-title">
    <div class="custom-modal">
      <h3 id="prompt-modal-title"></h3>
      <p id="prompt-modal-message"></p>
      <label for="prompt-modal-input" class="sr-only" id="prompt-modal-input-label">Enter value</label>
      <input type="text" id="prompt-modal-input" aria-labelledby="prompt-modal-input-label" />
      <div class="custom-modal-buttons">
        <button class="cancel-btn" id="prompt-modal-cancel-btn">Cancel</button>
        <button class="confirm-btn" id="prompt-modal-confirm-btn">Submit</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
  <script>
    // Self-executing anonymous function (IIFE) to encapsulate all variables and functions
    (function() {
      // PWA: Register Service Worker
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
              console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch(error => {
              console.error('Service Worker registration failed:', error);
              showToast('Service Worker registration failed. Offline features may be limited.', 'error');
            });
        });
      }

      // Monaco Editor Environment Setup
      window.MonacoEnvironment = {
        getWorkerUrl: function (workerId, label) {
          return `data:text/javascript;charset=utf-8,importScripts('https://unpkg.com/monaco-editor@0.52.0/min/vs/base/worker/workerMain.js');`;
        }
      };

      // --- Global State Variables (within IIFE scope) ---
      let editorInstance = null;
      let diffEditorInstance = null;
      let originalModel = null; // Stores content for diffing
      let currentLanguage = localStorage.getItem('arboEditorLanguage') || 'javascript';
      let currentTheme = localStorage.getItem('arboEditorTheme') || 'vs-dark';
      let isWordWrapEnabled = localStorage.getItem('arboEditorWordWrap') === 'true';
      let isMinimapEnabled = localStorage.getItem('arboEditorMinimap') !== 'false';
      let areLineNumbersEnabled = localStorage.getItem('arboEditorLineNumbers') !== 'false';
      let isReadOnlyMode = localStorage.getItem('arboEditorReadOnly') === 'true';
      let lastAutosaveContent = ''; // To prevent unnecessary cache writes
      let isMaximized = false;
      let isSidebarCollapsed = false;

      // Cache Storage Constants
      const CACHE_NAME = 'arbo-editor-content-cache-v1'; // Increment version on breaking changes
      const CACHE_KEY = 'current-arbo-editor-content';

      // --- DOM Element References ---
      const app = document.getElementById('app');
      const loadingOverlay = document.getElementById('loading-overlay');
      const sidebar = document.getElementById('sidebar');
      const editorContainer = document.getElementById('editor-container');
      const editorToolbar = document.getElementById('editor-toolbar');
      const container = document.getElementById('container');
      const statusBar = document.getElementById('status-bar');
      const readOnlyOverlay = document.getElementById('read-only-overlay');
      const langDisplay = document.getElementById('lang-display');
      const cursorPosDisplay = document.getElementById('cursor-pos');
      const wordCharCountDisplay = document.getElementById('word-char-count');
      const errorStatusDisplay = document.getElementById('error-status');
      const languageSelect = document.getElementById('language-select');
      const fontSizeSelect = document.getElementById('font-size-select');
      const themeToggleBtn = document.getElementById('theme-toggle-btn');
      const toggleWordWrapBtn = document.getElementById('toggle-word-wrap-btn');
      const toggleMinimapBtn = document.getElementById('toggle-minimap-btn');
      const toggleLineNumbersBtn = document.getElementById('toggle-line-numbers-btn');
      const readOnlyModeBtn = document.getElementById('read-only-mode-btn');
      const maximizeMinimizeBtn = document.getElementById('maximize-minimize-btn');
      const maximizeMinimizeIcon = maximizeMinimizeBtn.querySelector('.codicon');
      const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
      const formatCodeBtn = document.getElementById('format-code-btn');
      const diffContainer = document.getElementById('diff-container');
      const diffEditorDiv = document.getElementById('diff-editor');
      const keyLogDisplay = document.getElementById('key-logging-display');

      // Context Menu Elements
      const customContextMenu = document.getElementById('custom-context-menu');
      const contextCopyBtn = document.getElementById('context-copy-btn');
      const contextPasteBtn = document.getElementById('context-paste-btn');
      const contextCutBtn = document.getElementById('context-cut-btn');
      const contextSelectAllBtn = document.getElementById('context-select-all-btn');
      const contextFormatBtn = document.getElementById('context-format-btn');

      // Custom Modal Elements
      const customAlertModalOverlay = document.getElementById('custom-alert-modal-overlay');
      const alertModalTitle = document.getElementById('alert-modal-title');
      const alertModalMessage = document.getElementById('alert-modal-message');
      const alertModalOkBtn = document.getElementById('alert-modal-ok-btn');

      const customConfirmModalOverlay = document.getElementById('custom-confirm-modal-overlay');
      const confirmModalTitle = document.getElementById('confirm-modal-title');
      const confirmModalMessage = document.getElementById('confirm-modal-message');
      const confirmModalConfirmBtn = document.getElementById('confirm-modal-confirm-btn');
      const confirmModalCancelBtn = document.getElementById('confirm-modal-cancel-btn');

      const customPromptModalOverlay = document.getElementById('custom-prompt-modal-overlay');
      const promptModalTitle = document.getElementById('prompt-modal-title');
      const promptModalMessage = document.getElementById('prompt-modal-message');
      const promptModalInput = document.getElementById('prompt-modal-input');
      const promptModalConfirmBtn = document.getElementById('prompt-modal-confirm-btn');
      const promptModalCancelBtn = document.getElementById('prompt-modal-cancel-btn');

      // --- Utility Functions ---
      let toastTimeout;
      /**
       * Displays a toast notification.
       * @param {string} message - The message to display.
       * @param {'success'|'error'|'info'} type - The type of toast (affects color).
       */
      function showToast(message, type = 'info') {
        const toast = document.getElementById('toast-message');
        clearTimeout(toastTimeout);
        toast.textContent = message;
        toast.className = `toast show ${type}`;
        toastTimeout = setTimeout(() => {
          toast.classList.remove('show');
        }, 3000); // Increased duration to 3 seconds for better readability
      }

      let keyLogTimeout;
      /**
       * Displays the last pressed key briefly.
       * @param {string} key - The key pressed.
       */
      function showKeyLog(key) {
        clearTimeout(keyLogTimeout);
        keyLogDisplay.textContent = `Key: "${key}"`;
        keyLogDisplay.classList.add('show-key-log');
        keyLogTimeout = setTimeout(() => {
          keyLogDisplay.classList.remove('show-key-log');
        }, 500); // Slightly longer duration for visibility
      }

      /**
       * Debounces a function call.
       * @param {Function} func - The function to debounce.
       * @param {number} wait - The delay in milliseconds.
       * @returns {Function} The debounced function.
       */
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      /**
       * Gets file extension for a given Monaco language ID.
       * @param {string} lang - Monaco language ID.
       * @returns {string} The common file extension.
       */
      function getExtensionForLanguage(lang) {
        const extensions = {
          javascript: 'js', typescript: 'ts', html: 'html', css: 'css', json: 'json',
          python: 'py', java: 'java', csharp: 'cs', php: 'php', markdown: 'md',
          xml: 'xml', ruby: 'rb', go: 'go', swift: 'swift', kotlin: 'kt',
          rust: 'rs', sql: 'sql', yaml: 'yml', toml: 'toml', powershell: 'ps1',
          dockerfile: 'dockerfile', cpp: 'cpp', c: 'c', 'objective-c': 'm',
          perl: 'pl', r: 'r', shell: 'sh', plaintext: 'txt'
        };
        return extensions[lang] || 'txt';
      }

      /**
       * Gets Monaco language ID for a given file extension.
       * @param {string} ext - The file extension.
       * @returns {string} The corresponding Monaco language ID.
       */
      function getLanguageFromExtension(ext) {
        const languages = {
          js: 'javascript', ts: 'typescript', html: 'html', css: 'css', json: 'json',
          py: 'python', java: 'java', cs: 'csharp', php: 'php', md: 'markdown',
          xml: 'xml', rb: 'ruby', go: 'go', swift: 'swift', kt: 'kotlin',
          rs: 'rust', sql: 'sql', yml: 'yaml', yaml: 'yaml', toml: 'toml',
          ps1: 'powershell', dockerfile: 'dockerfile', cpp: 'cpp', cxx: 'cpp',
          hpp: 'cpp', c: 'c', h: 'c', m: 'objective-c', mm: 'objective-c',
          pl: 'perl', r: 'r', sh: 'shell', bash: 'shell', txt: 'plaintext'
        };
        return languages[ext.toLowerCase()] || 'plaintext';
      }

      /**
       * Checks if a language has a formatter available.
       * @param {string} languageId - The Monaco language ID.
       * @returns {Promise<boolean>} True if formatting is supported, false otherwise.
       */
      async function canFormatLanguage(languageId) {
        // Use a small delay to ensure language features are registered
        await new Promise(resolve => setTimeout(resolve, 50));
        const language = monaco.languages.getLanguages().find(lang => lang.id === languageId);
        return language && language.languageFeatures && language.languageFeatures.documentFormattingEditProvider;
      }

      // --- Custom Modals ---
      /**
       * Shows a custom alert modal.
       * @param {string} title - The title of the alert.
       * @param {string} message - The message of the alert.
       * @returns {Promise<void>} A promise that resolves when the alert is closed.
       */
      function showAlert(title, message) {
        return new Promise(resolve => {
          alertModalTitle.textContent = title;
          alertModalMessage.textContent = message;
          customAlertModalOverlay.classList.add('visible');
          alertModalOkBtn.focus();

          const cleanup = () => {
            customAlertModalOverlay.classList.remove('visible');
            alertModalOkBtn.removeEventListener('click', onClick);
            document.removeEventListener('keydown', onKeydown);
            resolve();
          };

          const onClick = () => cleanup();
          const onKeydown = (e) => {
            if (e.key === 'Enter' || e.key === 'Escape') {
              cleanup();
            }
          };

          alertModalOkBtn.addEventListener('click', onClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      /**
       * Shows a custom confirmation modal.
       * @param {string} title - The title of the confirmation.
       * @param {string} message - The message of the confirmation.
       * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false if cancelled.
       */
      function showConfirm(title, message) {
        return new Promise(resolve => {
          confirmModalTitle.textContent = title;
          confirmModalMessage.textContent = message;
          customConfirmModalOverlay.classList.add('visible');
          confirmModalConfirmBtn.focus();

          const cleanup = (result) => {
            customConfirmModalOverlay.classList.remove('visible');
            confirmModalConfirmBtn.removeEventListener('click', onConfirmClick);
            confirmModalCancelBtn.removeEventListener('click', onCancelClick);
            document.removeEventListener('keydown', onKeydown);
            resolve(result);
          };

          const onConfirmClick = () => cleanup(true);
          const onCancelClick = () => cleanup(false);
          const onKeydown = (e) => {
            if (e.key === 'Enter') {
              cleanup(true);
            } else if (e.key === 'Escape') {
              cleanup(false);
            }
          };

          confirmModalConfirmBtn.addEventListener('click', onConfirmClick);
          confirmModalCancelBtn.addEventListener('click', onCancelClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      /**
       * Shows a custom prompt modal.
       * @param {string} title - The title of the prompt.
       * @param {string} message - The message of the prompt.
       * @param {string} [defaultValue=''] - The default value for the input.
       * @returns {Promise<string|null>} A promise that resolves to the input value if submitted, null if cancelled.
       */
      function showPrompt(title, message, defaultValue = '') {
        return new Promise(resolve => {
          promptModalTitle.textContent = title;
          promptModalMessage.textContent = message;
          promptModalInput.value = defaultValue;
          customPromptModalOverlay.classList.add('visible');
          promptModalInput.focus();
          promptModalInput.select();

          const cleanup = (result) => {
            customPromptModalOverlay.classList.remove('visible');
            promptModalConfirmBtn.removeEventListener('click', onConfirmClick);
            promptModalCancelBtn.removeEventListener('click', onCancelClick);
            document.removeEventListener('keydown', onKeydown);
            resolve(result);
          };

          const onConfirmClick = () => cleanup(promptModalInput.value);
          const onCancelClick = () => cleanup(null);
          const onKeydown = (e) => {
            if (e.key === 'Enter') {
              cleanup(promptModalInput.value);
            } else if (e.key === 'Escape') {
              cleanup(null);
            }
          };

          promptModalConfirmBtn.addEventListener('click', onConfirmClick);
          promptModalCancelBtn.addEventListener('click', onCancelClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      // --- Cache Storage Functions ---
      async function saveToCache(content, showUserToast = true) {
        try {
          const cache = await caches.open(CACHE_NAME);
          const response = new Response(content, {
            headers: { 'Content-Type': 'text/plain' }
          });
          await cache.put(CACHE_KEY, response);
          if (showUserToast) {
            showToast('Content saved to Arbo Editor cache!', 'success');
          }
          lastAutosaveContent = content; // Update last autosaved content after successful save
        } catch (err) {
          console.error('Cache save error:', err);
          showToast('Failed to save to Arbo Editor cache. Check console for details.', 'error');
        }
      }

      async function loadFromCache() {
        try {
          const cache = await caches.open(CACHE_NAME);
          const response = await cache.match(CACHE_KEY);
          if (response) {
            return await response.text();
          }
          return null;
        } catch (err) {
          console.error('Cache load error:', err);
          return null;
        }
      }

      // --- Status Bar Updates ---
      function updateErrorStatus() {
        const model = editorInstance.getModel();
        const markers = monaco.editor.getModelMarkers({ resource: model.uri });
        const errorCount = markers.filter(marker => marker.severity === monaco.MarkerSeverity.Error).length;

        if (errorCount > 0) {
          errorStatusDisplay.style.display = 'inline-flex';
          errorStatusDisplay.innerHTML = `<span class="codicon codicon-error" aria-hidden="true"></span> Errors: ${errorCount}`;
        } else {
          errorStatusDisplay.style.display = 'none';
        }
      }

      const updateWordCharCount = debounce(() => {
        const text = editorInstance.getValue();
        const charCount = text.length;
        const wordCount = text.trim().split(/\s+/).filter(word => word.length > 0).length;
        wordCharCountDisplay.innerHTML = `<span class="codicon codicon-text-size" aria-hidden="true"></span> Words: ${wordCount} | Chars: ${charCount}`;
      }, 300);

      function updateCursorPosition() {
        const pos = editorInstance.getPosition();
        if (pos) {
          cursorPosDisplay.textContent = `Ln ${pos.lineNumber}, Col ${pos.column}`;
        }
      }

      /**
       * Updates the disabled state of the format buttons based on language support and selection.
       */
      async function updateFormatButtonState() {
          const isFormatEnabled = await canFormatLanguage(currentLanguage);
          formatCodeBtn.disabled = !isFormatEnabled || isReadOnlyMode;
          // Context menu format button is disabled if no selection OR not supported OR read-only
          contextFormatBtn.disabled = !isFormatEnabled || (editorInstance && editorInstance.getSelection().isEmpty()) || isReadOnlyMode;
      }

      // --- Core Editor Initialization ---
      async function initializeEditor() {
        // Show loading spinner
        loadingOverlay.classList.remove('hidden');

        const initialFontSize = parseInt(localStorage.getItem('arboEditorFontSize')) || 10;
        let initialContent = await loadFromCache();
        if (initialContent === null) {
            initialContent = localStorage.getItem('arboEditorContent') || '// Start coding in Arbo Editor!\nfunction greet() {\n  console.log("Hello, world!");\n}';
        }
        lastAutosaveContent = initialContent; // Set initial content for diffing

        // Set initial theme on the body for CSS variables
        document.body.classList.toggle('vs-light', currentTheme === 'vs-light');

        editorInstance = monaco.editor.create(container, {
          value: initialContent,
          language: currentLanguage,
          theme: currentTheme,
          automaticLayout: true,
          minimap: { enabled: isMinimapEnabled },
          scrollBeyondLastLine: false,
          fontSize: initialFontSize,
          lineNumbers: areLineNumbersEnabled ? 'on' : 'off',
          wordWrap: isWordWrapEnabled ? 'on' : 'off',
          tabSize: 2,
          renderWhitespace: 'none',
          contextmenu: false, // Custom context menu will handle this
          quickSuggestions: true,
          autoClosingBrackets: 'always',
          autoClosingQuotes: 'always',
          autoIndent: 'full',
          formatOnPaste: true,
          formatOnType: true,
          folding: true,
          smoothScrolling: true,
          readOnly: isReadOnlyMode,
          mouseWheelScrollSensitivity: 2.0
        });

        // Create original model for diff view. It will be updated with lastAutosaveContent when diff is opened.
        originalModel = monaco.editor.createModel(initialContent, currentLanguage);

        // Set initial UI values from localStorage or defaults
        languageSelect.value = currentLanguage;
        langDisplay.textContent = currentLanguage;
        fontSizeSelect.value = initialFontSize;

        // Set initial active states for toggle buttons
        toggleWordWrapBtn.classList.toggle('active', isWordWrapEnabled);
        toggleMinimapBtn.classList.toggle('active', isMinimapEnabled);
        toggleLineNumbersBtn.classList.toggle('active', areLineNumbersEnabled);
        readOnlyModeBtn.classList.toggle('active', isReadOnlyMode);
        readOnlyOverlay.classList.toggle('visible', isReadOnlyMode);
        themeToggleBtn.classList.toggle('active', currentTheme === 'vs-dark');

        // Dynamically set CSS variables for precise overlay positioning
        // Use requestAnimationFrame to ensure elements are rendered for accurate measurements
        requestAnimationFrame(() => {
          document.documentElement.style.setProperty('--toolbar-height', `${editorToolbar.offsetHeight}px`);
          document.documentElement.style.setProperty('--status-bar-height', `${statusBar.offsetHeight}px`);
        });

        // Initialize status bar content
        updateErrorStatus();
        updateWordCharCount();
        updateCursorPosition();
        updateFormatButtonState();

        // Hide loading spinner and show app
        loadingOverlay.classList.add('hidden');
        app.classList.add('loaded');
      }

      // --- Event Handlers and Listeners ---
      function setupEventListeners() {
        // Maximize/Minimize Button
        maximizeMinimizeBtn.addEventListener('click', () => {
            isMaximized = !isMaximized;
            app.classList.toggle('maximized-editor', isMaximized);
            // Sidebar collapses when maximized, expands when minimized
            sidebar.classList.toggle('collapsed', isMaximized);

            maximizeMinimizeIcon.classList.toggle('codicon-screen-full', !isMaximized);
            maximizeMinimizeIcon.classList.toggle('codicon-screen-normal', isMaximized);

            showToast(`Arbo Editor ${isMaximized ? 'maximized' : 'minimized'}.`, 'info');

            // Force layout of both editors after size change
            editorInstance.layout();
            if (diffEditorInstance) {
                diffEditorInstance.layout();
            }
        });

        // Toggle Sidebar Button
        toggleSidebarBtn.addEventListener('click', () => {
            isSidebarCollapsed = !isSidebarCollapsed;
            sidebar.classList.toggle('collapsed', isSidebarCollapsed);

            // Re-layout editor(s) after sidebar size change
            editorInstance.layout();
            if (diffEditorInstance) {
                diffEditorInstance.layout();
            }

            showToast(`Sidebar ${isSidebarCollapsed ? 'collapsed' : 'expanded'}`, 'info');
        });

        // Language Selection
        languageSelect.addEventListener('change', (event) => {
          currentLanguage = event.target.value;
          monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
          if (originalModel) {
            monaco.editor.setModelLanguage(originalModel, currentLanguage); // Keep original model language in sync
          }
          langDisplay.textContent = currentLanguage;
          localStorage.setItem('arboEditorLanguage', currentLanguage);
          updateErrorStatus();
          showToast(`Language set to ${currentLanguage.toUpperCase()}`, 'info');
          updateFormatButtonState();
        });

        // Font Size Adjustment
        fontSizeSelect.addEventListener('change', (event) => {
          const newSize = parseInt(event.target.value);
          editorInstance.updateOptions({ fontSize: newSize });
          if (diffEditorInstance) {
            diffEditorInstance.getOriginalEditor().updateOptions({ fontSize: newSize });
            diffEditorInstance.getModifiedEditor().updateOptions({ fontSize: newSize });
          }
          localStorage.setItem('arboEditorFontSize', newSize);
          showToast(`Font size set to ${newSize}px`, 'info');
        });

        // Theme Toggling
        themeToggleBtn.addEventListener('click', () => {
          currentTheme = currentTheme === 'vs-dark' ? 'vs-light' : 'vs-dark';
          monaco.editor.setTheme(currentTheme);
          document.body.classList.toggle('vs-light', currentTheme === 'vs-light'); // Update body class for CSS variables

          if (diffEditorInstance) {
            diffEditorInstance.getOriginalEditor().updateOptions({ theme: currentTheme });
            diffEditorInstance.getModifiedEditor().updateOptions({ theme: currentTheme });
          }
          localStorage.setItem('arboEditorTheme', currentTheme);
          themeToggleBtn.classList.toggle('active', currentTheme === 'vs-dark');
          showToast(`Switched to ${currentTheme === 'vs-dark' ? 'Dark' : 'Light'} Theme`, 'info');
        });

        // Word Wrap Toggling
        toggleWordWrapBtn.addEventListener('click', () => {
          isWordWrapEnabled = !isWordWrapEnabled;
          editorInstance.updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
          if (diffEditorInstance) {
            diffEditorInstance.getOriginalEditor().updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
            diffEditorInstance.getModifiedEditor().updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
          }
          localStorage.setItem('arboEditorWordWrap', isWordWrapEnabled);
          toggleWordWrapBtn.classList.toggle('active', isWordWrapEnabled);
          showToast(`Word Wrap ${isWordWrapEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Undo/Redo
        document.getElementById('undo-btn').addEventListener('click', () => {
          if (!isReadOnlyMode) {
              editorInstance.trigger('source', 'undo', {});
              showToast('Undo performed.', 'info');
          } else {
              showToast('Cannot undo in read-only mode.', 'info');
          }
        });

        document.getElementById('redo-btn').addEventListener('click', () => {
          if (!isReadOnlyMode) {
              editorInstance.trigger('source', 'redo', {});
              showToast('Redo performed.', 'info');
          } else {
              showToast('Cannot redo in read-only mode.', 'info');
          }
        });

        // Cursor Navigation
        document.getElementById('cursor-up-btn').addEventListener('click', () => { editorInstance.trigger('keyboard', 'cursorUp', {}); editorInstance.focus(); });
        document.getElementById('cursor-down-btn').addEventListener('click', () => { editorInstance.trigger('keyboard', 'cursorDown', {}); editorInstance.focus(); });
        document.getElementById('cursor-left-btn').addEventListener('click', () => { editorInstance.trigger('keyboard', 'cursorLeft', {}); editorInstance.focus(); });
        document.getElementById('cursor-right-btn').addEventListener('click', () => { editorInstance.trigger('keyboard', 'cursorRight', {}); editorInstance.focus(); });

        // Editor Status Updates
        editorInstance.onDidChangeCursorPosition(updateCursorPosition);

        const debounceSaveToCacheOnContentChange = debounce(async () => {
            const currentContent = editorInstance.getValue();
            if (currentContent !== lastAutosaveContent) {
                await saveToCache(currentContent, false); // Don't show toast for autosave
            }
        }, 1000);

        editorInstance.onDidChangeModelContent(() => {
          updateErrorStatus();
          updateWordCharCount();
          debounceSaveToCacheOnContentChange();
          // originalModel should NOT be updated here, it represents the *saved* state for diffing.
          updateFormatButtonState();
        });

        // New File
        document.getElementById('new-file-btn').addEventListener('click', async () => {
          const confirmed = await showConfirm('New File', 'Are you sure you want to create a new file? Any unsaved changes will be lost.');
          if (confirmed) {
            editorInstance.setValue('');
            if (originalModel) { originalModel.setValue(''); } // Reset original model for new file
            currentLanguage = 'plaintext';
            monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
            languageSelect.value = currentLanguage;
            langDisplay.textContent = currentLanguage;
            localStorage.setItem('arboEditorLanguage', currentLanguage);
            await saveToCache('');
            showToast('New file created!', 'success');
            updateFormatButtonState();
          } else {
            showToast('New file creation cancelled.', 'info');
          }
        });

        // Clear Editor
        document.getElementById('clear-editor-btn').addEventListener('click', async () => {
          const confirmed = await showConfirm('Clear Editor', 'Are you sure you want to clear the editor content? This action cannot be undone.');
          if (confirmed) {
            editorInstance.setValue('');
            if (originalModel) { originalModel.setValue(''); } // Reset original model
            await saveToCache('');
            showToast('Editor content cleared!', 'success');
            updateFormatButtonState();
          } else {
            showToast('Clear editor cancelled.', 'info');
          }
        });

        // Save to Cache (explicit save)
        document.getElementById('save-cache-btn').addEventListener('click', async () => {
          const content = editorInstance.getValue();
          await saveToCache(content, true);
          if (originalModel) { originalModel.setValue(content); } // Update original model to match current saved state
        });

        // Download Code
        document.getElementById('download-btn').addEventListener('click', async () => {
          const code = editorInstance.getValue();
          const defaultFileName = `untitled.${getExtensionForLanguage(currentLanguage)}`;
          const fileName = await showPrompt('Download Code', 'Enter desired file name:', defaultFileName);
          if (fileName) {
            try {
              const blob = new Blob([code], { type: 'text/plain' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = fileName;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              showToast(`File "${fileName}" downloaded!`, 'success');
            } catch (err) {
              console.error('Download error:', err);
              showToast('Failed to download file.', 'error');
            }
          } else {
            showToast('Download cancelled.', 'info');
          }
        });

        // Open File
        document.getElementById('open-file-btn').addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.js,.ts,.html,.css,.json,.py,.java,.cs,.php,.md,.xml,.rb,.go,.swift,.kt,.rs,.sql,.yml,.toml,.ps1,.dockerfile,.c,.cpp,.m,.pl,.r,.sh,.txt,text/*,application/json';
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
              const confirmed = await showConfirm('Open File', `Opening "${file.name}" will replace current editor content. Continue?`);
              if (!confirmed) {
                  showToast('File open cancelled.', 'info');
                  return;
              }

              try {
                const reader = new FileReader();
                reader.onload = async function(event) {
                  const fileContent = event.target.result;
                  editorInstance.setValue(fileContent);
                  originalModel.setValue(fileContent); // Update original model for diff

                  const fileNameParts = file.name.split('.');
                  const fileExtension = fileNameParts.length > 1 ? fileNameParts.pop().toLowerCase() : 'txt';
                  const detectedLanguage = getLanguageFromExtension(fileExtension);

                  const supportedLanguages = monaco.languages.getLanguages().map(lang => lang.id);
                  if (supportedLanguages.includes(detectedLanguage)) {
                    currentLanguage = detectedLanguage;
                    monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
                    monaco.editor.setModelLanguage(originalModel, currentLanguage);
                    languageSelect.value = currentLanguage;
                    langDisplay.textContent = currentLanguage;
                    localStorage.setItem('arboEditorLanguage', currentLanguage);
                    await saveToCache(fileContent);
                    showToast(`Opened "${file.name}" as ${currentLanguage.toUpperCase()}`, 'success');
                  } else {
                    currentLanguage = 'plaintext';
                    monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
                    monaco.editor.setModelLanguage(originalModel, currentLanguage);
                    languageSelect.value = currentLanguage;
                    langDisplay.textContent = currentLanguage;
                    localStorage.setItem('arboEditorLanguage', currentLanguage);
                    await saveToCache(fileContent);
                    showToast(`Opened "${file.name}" (language not detected, set to Plain Text)`, 'info');
                  }
                  updateFormatButtonState();
                };
                reader.onerror = () => {
                  showToast('Failed to read file. Check file permissions.', 'error');
                };
                reader.readAsText(file);
              } catch (err) {
                showToast('Error opening file. Check console for details.', 'error');
                console.error('File open error:', err);
              }
            } else {
                showToast('No file selected to open.', 'info');
            }
          };
          input.click();
        });

        // Code Formatting
        formatCodeBtn.addEventListener('click', async () => {
          if (isReadOnlyMode) {
            showToast('Cannot format code in read-only mode.', 'info');
            return;
          }
          try {
            if (await canFormatLanguage(currentLanguage)) {
              showToast('Formatting code...', 'info');
              await editorInstance.getAction('editor.action.formatDocument').run();
              showToast('Code formatted successfully!', 'success');
            } else {
              showToast('Formatting not supported for this language.', 'info');
            }
          } catch (err) {
            console.error('Formatting error:', err);
            showToast('Failed to format code. See console for details.', 'error');
          }
        });

        // Context Menu
        const editorContainerDiv = document.getElementById('container'); // Monaco's main container

        let touchTimer;
        const LONG_PRESS_THRESHOLD = 500;

        // Handle touchstart for long press to show context menu
        editorContainerDiv.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            let startX = touch.clientX;
            let startY = touch.clientY;
            touchTimer = setTimeout(() => {
              if (Math.abs(touch.clientX - startX) < 10 && Math.abs(touch.clientY - startY) < 10) {
                e.preventDefault();
                showContextMenu(touch.clientX, touch.clientY);
              }
            }, LONG_PRESS_THRESHOLD);
          }
        }, { passive: false });

        editorContainerDiv.addEventListener('touchmove', () => {
          clearTimeout(touchTimer);
        });

        editorContainerDiv.addEventListener('touchend', () => {
          clearTimeout(touchTimer);
        });

        // Native Monaco Context Menu override
        editorInstance.onContextMenu((e) => {
          e.event.preventDefault();
          showContextMenu(e.event.clientX, e.event.clientY);
        });

        /**
         * Shows the custom context menu at specified coordinates.
         * @param {number} x - ClientX coordinate.
         * @param {number} y - ClientY coordinate.
         */
        function showContextMenu(x, y) {
          const selection = editorInstance.getSelection();
          const hasSelection = !selection.isEmpty();

          contextCopyBtn.disabled = !hasSelection;
          contextCutBtn.disabled = !hasSelection || isReadOnlyMode;
          contextPasteBtn.disabled = isReadOnlyMode;
          contextFormatBtn.disabled = !hasSelection || !canFormatLanguage(currentLanguage) || isReadOnlyMode; // Ensure async check is handled

          customContextMenu.classList.add('show');
          customContextMenu.setAttribute('aria-hidden', 'false');

          let finalX = x;
          let finalY = y;
          const menuRect = customContextMenu.getBoundingClientRect(); // Get current size
          const menuWidth = menuRect.width;
          const menuHeight = menuRect.height;

          // Adjust position to keep it within viewport
          if (x + menuWidth > window.innerWidth - 10) {
            finalX = window.innerWidth - menuWidth - 10;
          }
          if (y + menuHeight > window.innerHeight - 10) {
            finalY = window.innerHeight - menuHeight - 10;
          }

          customContextMenu.style.left = `${Math.max(0, finalX)}px`;
          customContextMenu.style.top = `${Math.max(0, finalY)}px`;
          contextCopyBtn.focus(); // Focus the first actionable button
        }

        // Context Menu Keyboard Navigation
        const contextButtons = [contextCopyBtn, contextPasteBtn, contextCutBtn, contextFormatBtn, contextSelectAllBtn];
        contextButtons.forEach((btn, index) => {
          btn.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              let nextIndex = (index + 1) % contextButtons.length;
              while (contextButtons[nextIndex].disabled && nextIndex !== index) {
                  nextIndex = (nextIndex + 1) % contextButtons.length;
              }
              contextButtons[nextIndex].focus();
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              let prevIndex = (index - 1 + contextButtons.length) % contextButtons.length;
              while (contextButtons[prevIndex].disabled && prevIndex !== index) {
                  prevIndex = (prevIndex - 1 + contextButtons.length) % contextButtons.length;
              }
              contextButtons[prevIndex].focus();
            } else if (e.key === 'Escape') {
              hideContextMenu();
              editorInstance.focus();
            }
          });
        });

        /**
         * Hides the custom context menu.
         */
        function hideContextMenu() {
            customContextMenu.classList.remove('show');
            customContextMenu.setAttribute('aria-hidden', 'true');
        }

        // Hide context menu when clicking outside or tapping
        document.addEventListener('click', (e) => {
          if (!customContextMenu.contains(e.target) && !editorContainerDiv.contains(e.target)) {
            hideContextMenu();
          }
        });

        document.addEventListener('touchstart', (e) => {
            if (!customContextMenu.contains(e.target)) {
                hideContextMenu();
            }
        }, { passive: true }); // Passive listener for better performance on mobile

        // Handle 'focusout' from context menu buttons to hide the menu
        customContextMenu.addEventListener('focusout', (e) => {
            if (!customContextMenu.contains(e.relatedTarget)) {
                hideContextMenu();
            }
        });

        /**
         * Copies the currently selected text to the clipboard.
         */
        async function copySelectedText() {
          const selectedText = editorInstance.getModel().getValueInRange(editorInstance.getSelection());
          if (selectedText) {
            try {
              await navigator.clipboard.writeText(selectedText);
              showToast('Text copied to clipboard!', 'success');
            } catch (err) {
              console.error('Failed to copy text:', err);
              showToast('Failed to copy text. Please grant clipboard permissions.', 'error');
            }
          } else {
            showToast('No text selected to copy.', 'info');
          }
        }

        /**
         * Pastes text from the clipboard into the editor.
         */
        async function pasteText() {
          if (isReadOnlyMode) {
            showToast('Cannot paste in read-only mode.', 'info');
            return;
          }
          try {
            const text = await navigator.clipboard.readText();
            if (text) {
                editorInstance.trigger('source', 'paste', { text });
                showToast('Text pasted!', 'success');
            } else {
                showToast('Clipboard is empty, nothing to paste.', 'info');
            }
          } catch (err) {
              console.error('Failed to paste text:', err);
              showToast('Failed to paste text. Please grant clipboard permissions.', 'error');
          }
        }

        /**
         * Cuts the currently selected text to the clipboard.
         */
        async function cutSelectedText() {
          if (isReadOnlyMode) {
            showToast('Cannot cut in read-only mode.', 'info');
            return;
          }
          const selectedText = editorInstance.getModel().getValueInRange(editorInstance.getSelection());
          if (selectedText) {
            try {
              await navigator.clipboard.writeText(selectedText);
              editorInstance.trigger('source', 'cut');
              showToast('Text cut to clipboard!', 'success');
            } catch (err) {
              console.error('Failed to cut text:', err);
              showToast('Failed to cut text. Please grant clipboard permissions.', 'error');
            }
          } else {
            showToast('No text selected to cut.', 'info');
          }
        }

        contextCopyBtn.addEventListener('click', () => { copySelectedText(); hideContextMenu(); });
        contextPasteBtn.addEventListener('click', () => { pasteText(); hideContextMenu(); });
        contextCutBtn.addEventListener('click', () => { cutSelectedText(); hideContextMenu(); });
        contextFormatBtn.addEventListener('click', async () => {
          if (isReadOnlyMode) {
            showToast('Cannot format code in read-only mode.', 'info');
            hideContextMenu();
            return;
          }
          const selection = editorInstance.getSelection();
          try {
            if (await canFormatLanguage(currentLanguage)) {
              if (!selection.isEmpty()) {
                showToast('Formatting selection...', 'info');
                await editorInstance.getAction('editor.action.formatSelection').run();
                showToast('Selected code formatted!', 'success');
              } else {
                showToast('Formatting document...', 'info');
                await editorInstance.getAction('editor.action.formatDocument').run();
                showToast('Code formatted!', 'success');
              }
            } else {
              showToast('Formatting not supported for this language.', 'info');
            }
          } catch (err) {
            console.error('Formatting error:', err);
            showToast('Failed to format code. See console for details.', 'error');
          }
          hideContextMenu();
        });
        contextSelectAllBtn.addEventListener('click', () => {
          editorInstance.setSelection(editorInstance.getModel().getFullModelRange());
          editorInstance.focus();
          hideContextMenu();
          showToast('All text selected.', 'info');
        });

        document.getElementById('copy-all-btn').addEventListener('click', async () => {
          const allText = editorInstance.getValue();
          if (allText) {
            try {
              await navigator.clipboard.writeText(allText);
              showToast('All code copied to clipboard!', 'success');
            } catch (err) {
              console.error('Failed to copy all text:', err);
              showToast('Failed to copy all text. Please grant clipboard permissions.', 'error');
            }
          } else {
            showToast('Editor is empty, nothing to copy.', 'info');
          }
        });

        // Find/Replace: Trigger Monaco's built-in find widget
        document.getElementById('find-replace-btn').addEventListener('click', () => {
          editorInstance.getAction('actions.find').run();
          showToast('Find/Replace panel opened.', 'info');
        });

        // Diff View
        document.getElementById('diff-view-btn').addEventListener('click', () => {
          // Temporarily hide editor and show diff container
          editorContainer.style.display = 'none';
          diffContainer.classList.add('show');

          // Initialize diff editor if not already created
          if (!diffEditorInstance) {
            diffEditorInstance = monaco.editor.createDiffEditor(diffEditorDiv, {
              theme: currentTheme,
              automaticLayout: true,
              readOnly: true, // Original side is always read-only
              scrollBeyondLastLine: false,
              fontSize: editorInstance.getOptions().get(monaco.editor.EditorOption.fontSize),
              wordWrap: isWordWrapEnabled ? 'on' : 'off',
              minimap: { enabled: isMinimapEnabled },
              lineNumbers: areLineNumbersEnabled ? 'on' : 'off',
              folding: true,
              smoothScrolling: true,
              mouseWheelScrollSensitivity: 2.0
            });
          }

          // Ensure originalModel always reflects the state before current edits for meaningful diffs
          // This is the crucial fix for the diff view.
          originalModel.setValue(lastAutosaveContent);
          monaco.editor.setModelLanguage(originalModel, currentLanguage);

          diffEditorInstance.setModel({
            original: originalModel,
            modified: editorInstance.getModel()
          });

          // Set read-only state for the modified editor in diff view based on main editor's state
          diffEditorInstance.getModifiedEditor().updateOptions({ readOnly: isReadOnlyMode });

          // Force layout after the container becomes visible
          diffEditorInstance.layout();
          showToast('Diff view enabled.', 'info');
          diffEditorInstance.getModifiedEditor().focus();
        });

        document.getElementById('close-diff-btn').addEventListener('click', () => {
          diffContainer.classList.remove('show');
          // Use a timeout to allow transition to complete before changing display
          setTimeout(() => {
            editorContainer.style.display = 'flex';
            editorInstance.layout(); // Layout main editor
            editorInstance.focus(); // Focus main editor
            showToast('Diff view closed.', 'info');
          }, 300); // Match CSS transition duration
        });

        document.getElementById('accept-changes-btn').addEventListener('click', async () => {
          if (diffEditorInstance) {
            if (isReadOnlyMode) {
                showToast('Cannot accept changes in read-only mode.', 'info');
                return;
            }
            const modifiedContent = diffEditorInstance.getModifiedEditor().getValue();
            editorInstance.setValue(modifiedContent);
            originalModel.setValue(modifiedContent); // Update original model to match
            await saveToCache(modifiedContent); // Auto-save accepted changes

            showToast('Changes accepted from diff view!', 'success');
            diffContainer.classList.remove('show');
            setTimeout(() => {
                editorContainer.style.display = 'flex';
                editorInstance.layout();
                editorInstance.focus();
            }, 300);
          } else {
              showToast('No active diff view to accept changes from.', 'error');
          }
        });

        // Toggle Minimap
        toggleMinimapBtn.addEventListener('click', () => {
          isMinimapEnabled = !isMinimapEnabled;
          editorInstance.updateOptions({ minimap: { enabled: isMinimapEnabled } });
          if (diffEditorInstance) {
            diffEditorInstance.getOriginalEditor().updateOptions({ minimap: { enabled: isMinimapEnabled } });
            diffEditorInstance.getModifiedEditor().updateOptions({ minimap: { enabled: isMinimapEnabled } });
          }
          localStorage.setItem('arboEditorMinimap', isMinimapEnabled);
          toggleMinimapBtn.classList.toggle('active', isMinimapEnabled);
          showToast(`Minimap ${isMinimapEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Toggle Line Numbers
        toggleLineNumbersBtn.addEventListener('click', () => {
          areLineNumbersEnabled = !areLineNumbersEnabled;
          editorInstance.updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
          if (diffEditorInstance) {
            diffEditorInstance.getOriginalEditor().updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
            diffEditorInstance.getModifiedEditor().updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
          }
          localStorage.setItem('arboEditorLineNumbers', areLineNumbersEnabled);
          toggleLineNumbersBtn.classList.toggle('active', areLineNumbersEnabled);
          showToast(`Line Numbers ${areLineNumbersEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Toggle Read-Only Mode
        readOnlyModeBtn.addEventListener('click', () => {
          isReadOnlyMode = !isReadOnlyMode;
          editorInstance.updateOptions({ readOnly: isReadOnlyMode });
          localStorage.setItem('arboEditorReadOnly', isReadOnlyMode);
          readOnlyModeBtn.classList.toggle('active', isReadOnlyMode);
          readOnlyOverlay.classList.toggle('visible', isReadOnlyMode);
          showToast(`Editor is now ${isReadOnlyMode ? 'Read-Only' : 'Editable'}`, 'info');

          if (diffEditorInstance) {
            diffEditorInstance.getModifiedEditor().updateOptions({ readOnly: isReadOnlyMode });
          }
          updateFormatButtonState();
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', async (e) => {
          const keyName = e.key;
          if (keyName !== 'Shift' && keyName !== 'Control' && keyName !== 'Alt' && keyName !== 'Meta') {
              showKeyLog(keyName === ' ' ? 'Space' : keyName);
          }

          // Ctrl/Cmd + S for Save to Cache
          if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            const content = editorInstance.getValue();
            await saveToCache(content, true);
            if (originalModel) { originalModel.setValue(content); }
          }
          // Other shortcuts (like Ctrl/Cmd+F, Z, Y) are handled by Monaco's default keybindings.
        });
      }

      // Initialize Monaco and then setup event listeners
      require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.52.0/min/vs' } });
      require(['vs/editor/editor.main'], function () {
        initializeEditor().then(setupEventListeners);
      });
    })(); // End of IIFE
  </script>
  <style>
    /* Screen reader only style for labels */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
    /* Separate style for sidebar separators to avoid conflicting with hr element */
    .sidebar-separator {
      width: 80%;
      height: 1px;
      background-color: var(--border-color);
      margin: 0.5em 0;
    }
    .context-menu-separator {
      width: 80%;
      height: 1px;
      background-color: var(--border-color);
      margin: 0.3em auto;
    }
  </style>
</body>
</html>
