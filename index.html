<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#1c2526" />
  <link rel="manifest" href="/manifest.json" />
  <title>Arbo Editor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codicon/0.0.8/codicon.min.css" />
  <style>
    /* Basic Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      overflow: hidden; /* Prevent body scroll, handled by individual containers or scaling */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1e1e1e;
      color: #cccccc;
      /* Default font size for the entire app, influencing all 'em' units */
      font-size: 10px; /* Base font size reduced for overall smaller UI */
    }

    #app {
      display: flex;
      height: 100%;
      opacity: 0; /* Initially hidden, show after editor loads */
      transition: opacity 0.3s ease-in-out;
      overflow: hidden; /* Ensure app itself doesn't cause unexpected scrolls */
    }

    #app.loaded {
      opacity: 1;
    }

    /* Loading Spinner */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1e1e1e;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      opacity: 1;
      transition: opacity 0.3s ease-in-out;
    }

    #loading-overlay.hidden {
      opacity: 0;
      pointer-events: none; /* Allow interaction with content underneath */
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #007acc;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Sidebar */
    #sidebar {
      width: 50px; /* Smaller sidebar width */
      background: #333333;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 5px; /* Reduced padding */
      border-right: 1px solid #444444;
      overflow-y: auto; /* Allow sidebar to scroll if content exceeds height */
      flex-shrink: 0;
      transition: width 0.3s ease, transform 0.3s ease; /* Add transform for smooth hiding */
    }

    #sidebar.collapsed { /* New class for collapsing sidebar */
        width: 0;
        padding-left: 0;
        padding-right: 0;
        border-right: none;
        /* Optionally, hide content when collapsed if needed for full effect */
        overflow: hidden;
    }

    #sidebar.hidden { /* Existing class, may be redundant or used differently */
        transform: translateX(-100%);
        width: 0;
        padding-left: 0;
        padding-right: 0;
        border-right: none;
    }

    #sidebar button, #sidebar select {
      background: none;
      border: none;
      color: #cccccc;
      cursor: pointer;
      padding: 8px; /* Reduced padding for buttons */
      width: 100%;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4em; /* Relative to body font size */
      margin-bottom: 3px; /* Reduced margin */
      border-radius: 4px;
      transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease;
    }

    #sidebar button:hover, #sidebar select:hover {
      background: #555555;
      color: #ffffff;
      transform: scale(1.02);
    }

    #sidebar button:active {
      transform: scale(0.98);
    }

    #sidebar button.active {
      background: #007acc;
      color: #ffffff;
    }

    #sidebar button .codicon, #sidebar select .codicon {
      font-size: 1.8em; /* Relative to button font size */
      transition: transform 0.2s ease;
    }

    #sidebar select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: #333333;
      border: 1px solid #444444;
      padding: 3px 0; /* Reduced padding */
      font-size: 1.2em;
      color: #cccccc;
      text-align-last: center;
      transition: border-color 0.2s ease, background-color 0.2s ease;
      position: relative;
    }

    #sidebar select:hover {
      border-color: #007acc;
    }

    #sidebar select option {
      background-color: #333333;
      color: #cccccc;
    }

    #font-size-select-wrapper, #language-select-wrapper {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 3px; /* Reduced margin */
    }

    #font-size-select-wrapper .codicon, #language-select-wrapper .codicon {
      position: absolute;
      left: 5px; /* Adjusted icon position */
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5em;
      color: #cccccc;
      pointer-events: none;
    }

    #font-size-select, #language-select {
      padding-left: 20px; /* Adjusted for smaller icon */
      width: 100%;
      height: 30px; /* Smaller height */
    }

    /* Editor Container */
    #editor-container {
      flex: 1;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: #1e1e1e;
      transition: all 0.3s ease;
      position: relative; /* For read-only overlay */
    }

    /* Maximized state for editor-container */
    #app.maximized-editor #editor-container {
      position: fixed; /* Use fixed for true full screen */
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 100;
      margin-left: 0;
    }

    /* Top Toolbar for Editor */
    #editor-toolbar {
      background: #252526;
      padding: 3px 8px; /* Reduced padding */
      display: flex;
      gap: 5px; /* Reduced gap */
      border-bottom: 1px solid #333333;
      align-items: center;
      flex-shrink: 0; /* Prevent toolbar from shrinking */
    }

    #editor-toolbar button {
      background: none;
      border: none;
      color: #cccccc;
      cursor: pointer;
      padding: 3px 6px; /* Reduced padding */
      font-size: 1.3em;
      border-radius: 4px;
      transition: background-color 0.2s ease, color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #editor-toolbar button:hover {
      background: #555555;
      color: #ffffff;
    }

    #editor-toolbar button .codicon {
      font-size: 1.6em; /* Relative to button font size */
    }

    /* Monaco Editor Wrapper */
    #container {
      flex: 1;
      width: 100%;
      transition: opacity 0.3s ease;
    }

    /* Read-Only Overlay */
    .read-only-overlay {
      position: absolute;
      /* Adjusted top to consider toolbar height using CSS variable */
      top: var(--toolbar-height);
      left: 0;
      width: 100%;
      /* Adjusted height to cover only the editor area, excluding toolbar and status bar */
      height: calc(100% - var(--toolbar-height) - var(--status-bar-height));
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 2em; /* Smaller font for overlay text */
      font-weight: bold;
      z-index: 50;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    .read-only-overlay.visible {
      opacity: 1;
    }

    /* Status Bar */
    #status-bar {
      background: #007acc;
      color: #ffffff;
      padding: 4px 8px; /* Reduced padding */
      font-size: 1.1em; /* Smaller font size */
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px; /* Reduced gap */
      flex-shrink: 0; /* Crucial: Prevents status bar from shrinking and hiding content */
      transition: background-color 0.2s ease;
    }

    #status-bar span {
      display: flex;
      align-items: center;
      gap: 3px; /* Reduced gap */
      transition: color 0.2s ease;
    }

    .codicon {
      font-family: 'codicon';
      font-size: 1em; /* Base icon size relative to parent font size */
      transition: color 0.2s ease;
    }

    /* Custom Context Menu */
    #custom-context-menu {
      position: absolute;
      background: #252526;
      border: 1px solid #444444;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
      padding: 3px 0; /* Reduced padding */
      opacity: 0;
      transform: scale(0.95);
      transform-origin: top left;
      transition: opacity 0.15s ease-out, transform 0.15s ease-out;
    }

    #custom-context-menu.show {
      display: block;
      opacity: 1;
      transform: scale(1);
    }

    #custom-context-menu button {
      background: none;
      border: none;
      color: #cccccc;
      padding: 6px 10px; /* Reduced padding */
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 1.2em; /* Smaller font size */
      display: flex;
      align-items: center;
      gap: 5px; /* Reduced gap */
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    #custom-context-menu button:hover, #custom-context-menu button:focus {
      background: #007acc;
      color: #ffffff;
      outline: none;
    }

    #custom-context-menu button:disabled {
      color: #777777;
      cursor: not-allowed;
      background: none;
      opacity: 0.6;
    }

    /* Toast Notification */
    .toast {
      visibility: hidden;
      min-width: 200px; /* Smaller min-width */
      background-color: #333;
      color: #fff;
      text-align: center;
      border-radius: 4ഴും;
      padding: 8px 12px; /* Reduced padding */
      position: fixed;
      z-index: 1001;
      left: 50%;
      transform: translateX(-50%) translateY(15px); /* Adjusted vertical position */
      bottom: 20px; /* Adjusted bottom position */
      font-size: 1.2em; /* Smaller font size */
      opacity: 0;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out, background-color 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); /* Smaller shadow */
    }

    .toast.show {
      visibility: visible;
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast.success {
        background-color: #4CAF50;
    }

    .toast.error {
        background-color: #f44336;
    }

    .toast.info {
        background-color: #2196F3;
    }

    /* Diff View Styles */
    #diff-container {
      display: none;
      flex-direction: column;
      height: 100%;
      width: 100%;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      flex: 1;
    }

    #diff-container.show {
        display: flex;
        opacity: 1;
    }

    #diff-toolbar {
      background: #252526;
      padding: 5px 8px; /* Reduced padding */
      display: flex;
      gap: 8px; /* Reduced gap */
      border-bottom: 1px solid #333333;
      align-items: center;
      justify-content: flex-end;
      flex-shrink: 0;
      transition: background-color 0.2s ease;
    }

    #diff-toolbar button {
      background: #007acc;
      color: #ffffff;
      border: none;
      padding: 4px 8px; /* Reduced padding */
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.2em; /* Smaller font size */
      display: flex;
      align-items: center;
      gap: 3px; /* Reduced gap */
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    #diff-toolbar button:hover {
      background: #005f99;
      transform: scale(1.02);
    }

    #diff-toolbar button:active {
      transform: scale(0.98);
    }

    #diff-editor {
      flex: 1;
      width: 100%;
    }

    /* Custom Modal Styles */
    .custom-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1002;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }

    .custom-modal-overlay.visible {
        opacity: 1;
        visibility: visible;
    }

    .custom-modal {
        background: #252526;
        padding: 15px; /* Reduced padding */
        border-radius: 6px; /* Slightly smaller border-radius */
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4); /* Smaller shadow */
        max-width: 350px; /* Smaller max-width */
        width: 85%; /* Adjusted width */
        color: #cccccc;
        transform: translateY(-15px); /* Adjusted vertical position */
        transition: transform 0.3s ease-in-out;
    }

    .custom-modal-overlay.visible .custom-modal {
        transform: translateY(0);
    }

    .custom-modal h3 {
        margin-top: 0;
        color: #e0e0e0;
        font-size: 1.2em; /* Smaller font size */
        margin-bottom: 10px; /* Reduced margin */
    }

    .custom-modal p {
        margin-bottom: 15px; /* Reduced margin */
        line-height: 1.4; /* Slightly tighter line height */
        font-size: 0.9em; /* Smaller font size */
    }

    .custom-modal input[type="text"] {
        width: 100%;
        padding: 8px; /* Reduced padding */
        margin-bottom: 15px; /* Reduced margin */
        border: 1px solid #444444;
        background-color: #333333;
        color: #cccccc;
        border-radius: 4px;
        font-size: 1em;
    }

    .custom-modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 8px; /* Reduced gap */
    }

    .custom-modal-buttons button {
        padding: 6px 12px; /* Reduced padding */
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9em; /* Smaller font size */
        transition: background-color 0.2s ease, transform 0.1s ease;
    }

    .custom-modal-buttons button.confirm-btn {
        background-color: #007acc;
        color: #ffffff;
    }

    .custom-modal-buttons button.confirm-btn:hover {
        background-color: #005f99;
        transform: scale(1.02);
    }

    .custom-modal-buttons button.cancel-btn {
        background-color: #555555;
        color: #ffffff;
    }

    .custom-modal-buttons button.cancel-btn:hover {
        background-color: #666666;
        transform: scale(1.02);
    }

    /* Media query for desktop-like experience on smaller screens */
    /* This will scale the entire body down, making it appear as if on a desktop,
       and then enable scrolling to see the full content. */
    @media (max-width: 768px) {
        html, body {
            overflow: auto; /* Allow scrolling/sliding on smaller screens */
        }
        body {
            /* Adjust this scale value to your preference. 0.6-0.7 is even smaller. */
            transform: scale(0.65); /* Even smaller scale for a truly "tiny" feel */
            transform-origin: top left;
            /* Calculate width/height to ensure the scaled content fills the original viewport space */
            width: calc(100vw / 0.65);
            height: calc(100vh / 0.65);
        }

        /* Adjust UI elements to be more usable after scaling */
        #sidebar {
            width: 60px; /* Slightly wider sidebar when scaled down but still small */
        }
        #sidebar button, #sidebar select {
            font-size: 1.6em; /* Adjust font size for better readability after scaling */
            padding: 10px;
        }
        #sidebar button .codicon, #sidebar select .codicon {
            font-size: 2.2em; /* Larger icons */
        }
        #font-size-select, #language-select {
          padding-left: 25px; /* Adjust for larger icon */
          height: 35px; /* Make taller for easier touch */
          font-size: 1.3em;
        }

        #editor-toolbar {
            padding: 5px 10px;
            gap: 8px;
        }
        #editor-toolbar button {
            font-size: 1.5em;
            padding: 5px 8px;
        }
        #editor-toolbar button .codicon {
            font-size: 1.8em;
        }

        #status-bar {
            font-size: 1.3em;
            padding: 5px 10px;
        }
        #status-bar .codicon {
            font-size: 1.5em;
        }

        .toast {
            min-width: unset;
            width: 90%;
            left: 5%;
            transform: translateX(0%) translateY(20px) scale(calc(1/0.65)); /* Counter-scale toast so it doesn't shrink */
            transform-origin: bottom center;
            bottom: 25px;
            padding: 12px 16px;
            font-size: 1.5em;
        }
        .toast.show {
            transform: translateX(0%) translateY(0) scale(calc(1/0.65));
        }

        .custom-modal-overlay {
            /* Counter-scale modal overlay so it covers correctly */
            transform: scale(calc(1/0.65));
            transform-origin: top left;
            width: 100vw;
            height: 100vh;
        }
        .custom-modal {
            max-width: 500px; /* Larger modal for readability */
            padding: 25px;
            transform: translateY(-20px) scale(calc(1/0.65)); /* Counter-scale modal content */
        }
        .custom-modal-overlay.visible .custom-modal {
            transform: translateY(0) scale(calc(1/0.65));
        }
        .custom-modal h3 {
            font-size: 1.5em;
        }
        .custom-modal p {
            font-size: 1em;
        }
        .custom-modal input[type="text"] {
            font-size: 1em;
            padding: 10px;
        }
        .custom-modal-buttons button {
            font-size: 1em;
            padding: 8px 15px;
        }

        #custom-context-menu {
            /* Counter-scale context menu */
            transform: scale(calc(1/0.65));
            transform-origin: top left;
            font-size: 1em;
        }
        #custom-context-menu.show {
            transform: scale(calc(1/0.65));
        }
        #custom-context-menu button {
            padding: 8px 12px;
            font-size: 1.3em;
        }
        #custom-context-menu button .codicon {
            font-size: 1.6em;
        }
    }

    /* General responsive adjustments for very small screens, if needed */
    @media (max-width: 480px) {
        body {
            transform: scale(0.55); /* Even more aggressive scaling for tiny screens */
            width: calc(100vw / 0.55);
            height: calc(100vh / 0.55);
        }

        #sidebar {
            width: 55px; /* Adjust sidebar width */
            padding-top: 3px;
        }
        #sidebar button, #sidebar select {
            padding: 6px;
            font-size: 1.5em;
        }
        #sidebar button .codicon, #sidebar select .codicon {
            font-size: 2em;
        }
        #font-size-select, #language-select {
          padding-left: 20px;
          height: 30px;
          font-size: 1.2em;
        }

        #editor-toolbar {
            padding: 3px 5px;
            gap: 3px;
        }
        #editor-toolbar button {
            font-size: 1.3em;
            padding: 3px 6px;
        }
        #editor-toolbar button .codicon {
            font-size: 1.6em;
        }

        #status-bar {
            font-size: 1.1em;
            padding: 4px 5px;
        }
        #status-bar .codicon {
            font-size: 1.3em;
        }

        .toast {
            bottom: 15px;
            padding: 10px 14px;
            font-size: 1.3em;
        }
        .custom-modal {
            max-width: 90%; /* Make modal nearly full width on very small screens */
            padding: 15px;
        }
        .custom-modal h3 {
            font-size: 1.3em;
        }
        .custom-modal p {
            font-size: 0.9em;
        }
        .custom-modal input[type="text"] {
            font-size: 0.9em;
            padding: 8px;
        }
        .custom-modal-buttons button {
            font-size: 0.9em;
            padding: 6px 12px;
        }
    }
    
    /* New style for key logging display */
    #key-logging-display {
      background-color: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 4px 8px; /* Reduced padding */
      border-radius: 4px;
      font-size: 0.9em; /* Smaller font size */
      position: absolute; /* Position relative to its parent (editor-container) */
      bottom: 3px; /* Adjusted as needed, e.g., above status bar */
      right: 3px;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.1s ease-in-out;
      pointer-events: none; /* Allows clicks to pass through */
      display: none; /* Hidden by default */
    }

    #key-logging-display.show-key-log {
      opacity: 1;
      display: block;
    }
  </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="spinner"></div>
  </div>

  <div id="app">
    <div id="sidebar">
      <button id="new-file-btn" title="New File" aria-label="New File">
        <span class="codicon codicon-new-file"></span>
      </button>
      <button id="open-file-btn" title="Open File" aria-label="Open File">
        <span class="codicon codicon-folder-opened"></span>
      </button>
      <button id="save-cache-btn" title="Save to Cache" aria-label="Save to Cache">
        <span class="codicon codicon-save"></span>
      </button>
      <button id="download-btn" title="Download Code" aria-label="Download Code">
        <span class="codicon codicon-cloud-download"></span>
      </button>
      <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 5px 0;" />
      <div id="language-select-wrapper">
        <span class="codicon codicon-file-code"></span>
        <select id="language-select" title="Select Language" aria-label="Select Programming Language">
          <option value="javascript">JS</option>
          <option value="typescript">TS</option>
          <option value="html">HTML</option>
          <option value="css">CSS</option>
          <option value="json">JSON</option>
          <option value="python">PY</option>
          <option value="java">Java</option>
          <option value="csharp">C#</option>
          <option value="php">PHP</option>
          <option value="markdown">MD</option>
          <option value="xml">XML</option>
          <option value="ruby">Ruby</option>
          <option value="go">Go</option>
          <option value="swift">Swift</option>
          <option value="kotlin">Kotlin</option>
          <option value="rust">Rust</option>
          <option value="sql">SQL</option>
          <option value="yaml">YAML</option>
          <option value="toml">TOML</option>
          <option value="powershell">PS</option>
          <option value="dockerfile">Docker</option>
          <option value="cpp">C++</option>
          <option value="c">C</option>
          <option value="objective-c">Obj-C</option>
          <option value="perl">Perl</option>
          <option value="r">R</option>
          <option value="shell">Shell</option>
          <option value="plaintext">Text</option>
        </select>
      </div>
      <div id="font-size-select-wrapper">
        <span class="codicon codicon-text-size"></span>
        <select id="font-size-select" title="Font Size" aria-label="Select Font Size">
          <option value="7">7px</option>
          <option value="9">9px</option>
          <option value="10" selected>10px</option>
          <option value="12">12px</option>
          <option value="14">14px</option>
          <option value="16">16px</option>
          <option value="18">18px</option>
          <option value="20">20px</option>
          <option value="24">24px</option>
        </select>
      </div>
      <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 5px 0;" />
      <button id="copy-all-btn" title="Copy All Code" aria-label="Copy All Code">
        <span class="codicon codicon-copy"></span>
      </button>
      <button id="format-code-btn" title="Format Code" aria-label="Format Code">
        <span class="codicon codicon-symbol-ruler"></span>
      </button>
      <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 5px 0;" />
      <button id="find-replace-btn" title="Find/Replace" aria-label="Find Text">
        <span class="codicon codicon-search"></span>
      </button>
      <button id="toggle-word-wrap-btn" title="Toggle Word Wrap" aria-label="Toggle Word Wrap">
        <span class="codicon codicon-word-wrap"></span>
      </button>
      <button id="diff-view-btn" title="Compare with Original" aria-label="Compare Code with Original">
        <span class="codicon codicon-diff"></span>
      </button>
      <button id="theme-toggle-btn" title="Toggle Theme" aria-label="Toggle Editor Theme">
        <span class="codicon codicon-lightbulb"></span>
      </button>
      <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 5px 0;" />
      <button id="toggle-minimap-btn" title="Toggle Minimap" aria-label="Toggle Code Minimap">
        <span class="codicon codicon-map"></span>
      </button>
      <button id="toggle-line-numbers-btn" title="Toggle Line Numbers" aria-label="Toggle Line Numbers">
        <span class="codicon codicon-list-ordered"></span>
      </button>
      <button id="read-only-mode-btn" title="Toggle Read-Only Mode" aria-label="Toggle Read-Only Mode">
        <span class="codicon codicon-lock"></span>
      </button>
      <button id="clear-editor-btn" title="Clear Editor" aria-label="Clear All Editor Content">
        <span class="codicon codicon-clear-all"></span>
      </button>
    </div>
    <div id="editor-container">
      <div id="editor-toolbar">
        <button id="toggle-sidebar-btn" title="Toggle Sidebar" aria-label="Toggle Sidebar">
            <span class="codicon codicon-three-bars"></span>
        </button>
        <button id="undo-btn" title="Undo" aria-label="Undo Last Action">
          <span class="codicon codicon-arrow-left"></span> </button>
        <button id="redo-btn" title="Redo" aria-label="Redo Last Action">
          <span class="codicon codicon-arrow-right"></span>
        </button>
        <div style="flex-grow: 1;"></div> 
        <button id="maximize-minimize-btn" title="Maximize/Minimize Window" aria-label="Maximize/Minimize Window">
          <span class="codicon codicon-screen-full"></span>
        </button>
        <button id="cursor-up-btn" title="Move Cursor Up" aria-label="Move Cursor Up">
            <span class="codicon codicon-arrow-up"></span>
        </button>
        <button id="cursor-down-btn" title="Move Cursor Down" aria-label="Move Cursor Down">
            <span class="codicon codicon-arrow-down"></span>
        </button>
        <button id="cursor-left-btn" title="Move Cursor Left" aria-label="Move Cursor Left">
            <span class="codicon codicon-arrow-left"></span>
        </button>
        <button id="cursor-right-btn" title="Move Cursor Right" aria-label="Move Cursor Right">
            <span class="codicon codicon-arrow-right"></span>
        </button>
      </div>
      <div id="container"></div>
      <div class="read-only-overlay" id="read-only-overlay">
        <span class="codicon codicon-lock"></span> READ-ONLY
      </div>
      <div id="status-bar">
        <span><span class="codicon codicon-symbol-text" aria-hidden="true"></span> <span id="lang-display" aria-live="polite">javascript</span></span>
        <span><span class="codicon codicon-pencil" aria-hidden="true"></span> <span id="cursor-pos" aria-live="polite">Ln 1, Col 1</span></span>
        <span id="word-char-count" aria-live="polite"><span class="codicon codicon-text-size" aria-hidden="true"></span> Words: 0 | Chars: 0</span>
        <span id="error-status" style="color: #f44336; margin-left: auto; display: none;" aria-live="polite" role="status"><span class="codicon codicon-error" aria-hidden="true"></span> Errors: 0</span>
      </div>
      <div id="key-logging-display" class="toast" role="status" aria-live="polite"></div>
    </div>
    <div id="diff-container">
      <div id="diff-toolbar">
        <button id="close-diff-btn" title="Close Diff View" aria-label="Close Diff View">
          <span class="codicon codicon-close" aria-hidden="true"></span> Close Diff
        </button>
        <button id="accept-changes-btn" title="Accept Changes" aria-label="Accept Changes from Diff View">
          <span class="codicon codicon-check" aria-hidden="true"></span> Accept Changes
        </button>
      </div>
      <div id="diff-editor"></div>
    </div>
  </div>
  <div id="custom-context-menu" role="menu" aria-hidden="true">
    <button id="context-copy-btn" role="menuitem" aria-label="Copy Selected Text"><span class="codicon codicon-copy" aria-hidden="true"></span> Copy</button>
    <button id="context-paste-btn" role="menuitem" aria-label="Paste Text"><span class="codicon codicon-paste" aria-hidden="true"></span> Paste</button>
    <button id="context-cut-btn" role="menuitem" aria-label="Cut Selected Text"><span class="codicon codicon-cut" aria-hidden="true"></span> Cut</button>
    <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 3px auto;" />
    <button id="context-format-btn" role="menuitem" aria-label="Format Selection or Document"><span class="codicon codicon-symbol-ruler" aria-hidden="true"></span> Format Selection</button>
    <hr style="width: 80%; border: 0; border-top: 1px solid #444444; margin: 3px auto;" />
    <button id="context-select-all-btn" role="menuitem" aria-label="Select All Text"><span class="codicon codicon-whole-word" aria-hidden="true"></span> Select All</button>
  </div>
  <div id="toast-message" class="toast" role="alert" aria-live="assertive"></div>

  <div id="custom-alert-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog">
    <div class="custom-modal">
      <h3 id="alert-modal-title"></h3>
      <p id="alert-modal-message"></p>
      <div class="custom-modal-buttons">
        <button class="confirm-btn" id="alert-modal-ok-btn">OK</button>
      </div>
    </div>
  </div>

  <div id="custom-confirm-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog">
    <div class="custom-modal">
      <h3 id="confirm-modal-title"></h3>
      <p id="confirm-modal-message"></p>
      <div class="custom-modal-buttons">
        <button class="cancel-btn" id="confirm-modal-cancel-btn">Cancel</button>
        <button class="confirm-btn" id="confirm-modal-confirm-btn">Confirm</button>
      </div>
    </div>
  </div>

  <div id="custom-prompt-modal-overlay" class="custom-modal-overlay" aria-modal="true" role="dialog">
    <div class="custom-modal">
      <h3 id="prompt-modal-title"></h3>
      <p id="prompt-modal-message"></p>
      <input type="text" id="prompt-modal-input" />
      <div class="custom-modal-buttons">
        <button class="cancel-btn" id="prompt-modal-cancel-btn">Cancel</button>
        <button class="confirm-btn" id="prompt-modal-confirm-btn">Submit</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
  <script>
    // PWA: Register Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }

    // Arbo Editor Setup
    window.MonacoEnvironment = {
      getWorkerUrl: function (workerId, label) {
        return `data:text/javascript;charset=utf-8,importScripts('https://unpkg.com/monaco-editor@0.52.0/min/vs/base/worker/workerMain.js');`;
      }
    };

    let editorInstance = null;
    let diffEditorInstance = null;
    let originalModel = null;
    let currentLanguage = localStorage.getItem('arboEditorLanguage') || 'javascript';
    let currentTheme = localStorage.getItem('arboEditorTheme') || 'vs-dark';
    let isWordWrapEnabled = localStorage.getItem('arboEditorWordWrap') === 'true';
    let isMinimapEnabled = localStorage.getItem('arboEditorMinimap') !== 'false';
    let areLineNumbersEnabled = localStorage.getItem('arboEditorLineNumbers') !== 'false';
    let isReadOnlyMode = localStorage.getItem('arboEditorReadOnly') === 'true';
    let lastAutosaveContent = '';
    let isMaximized = false; // Tracks maximization state
    let isSidebarCollapsed = false; // New state for sidebar

    // Cache Storage Setup
    const CACHE_NAME = 'arbo-editor-content-cache';
    const CACHE_KEY = 'current-arbo-editor-content';

    require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.52.0/min/vs' } });
    require(['vs/editor/editor.main'], function () {
      // --- Initialize Arbo Editor ---
      async function initializeEditor() {
        const loadingOverlay = document.getElementById('loading-overlay');
        const app = document.getElementById('app');

        // Show loading spinner
        loadingOverlay.classList.remove('hidden');

        const initialFontSize = parseInt(localStorage.getItem('arboEditorFontSize')) || 10;
        // Load content from cache first, then localStorage, then default
        let initialContent = await loadFromCache();
        if (initialContent === null) { // If not found in cache
            initialContent = localStorage.getItem('arboEditorContent') || '// Start coding in Arbo Editor!\nfunction greet() {\n  console.log("Hello, world!");\n}';
        }
        lastAutosaveContent = initialContent; // Set for initial comparison

        editorInstance = monaco.editor.create(document.getElementById('container'), {
          value: initialContent,
          language: currentLanguage,
          theme: currentTheme,
          automaticLayout: true,
          minimap: { enabled: isMinimapEnabled },
          scrollBeyondLastLine: false,
          fontSize: initialFontSize,
          lineNumbers: areLineNumbersEnabled ? 'on' : 'off',
          wordWrap: isWordWrapEnabled ? 'on' : 'off',
          tabSize: 2,
          renderWhitespace: 'none', // Keep consistent with existing
          contextmenu: false, // Custom context menu will handle this
          quickSuggestions: true,
          autoClosingBrackets: 'always',
          autoClosingQuotes: 'always',
          autoIndent: 'full',
          formatOnPaste: true,
          formatOnType: true,
          folding: true,
          smoothScrolling: true,
          readOnly: isReadOnlyMode,
          mouseWheelScrollSensitivity: 2.0
        });

        // Create original model for diff view; ensure it reflects initial content
        originalModel = monaco.editor.createModel(initialContent, currentLanguage);

        // Set initial UI values from localStorage or defaults
        document.getElementById('language-select').value = currentLanguage;
        document.getElementById('lang-display').textContent = currentLanguage;
        document.getElementById('font-size-select').value = initialFontSize;

        // Set initial active states for toggle buttons
        document.getElementById('toggle-word-wrap-btn').classList.toggle('active', isWordWrapEnabled);
        document.getElementById('toggle-minimap-btn').classList.toggle('active', isMinimapEnabled);
        document.getElementById('toggle-line-numbers-btn').classList.toggle('active', areLineNumbersEnabled);
        document.getElementById('read-only-mode-btn').classList.toggle('active', isReadOnlyMode);
        document.getElementById('read-only-overlay').classList.toggle('visible', isReadOnlyMode);
        document.getElementById('theme-toggle-btn').classList.toggle('active', currentTheme === 'vs-dark'); // Active if dark theme

        // Set CSS variables for overlay positioning dynamically
        const editorToolbarHeight = document.getElementById('editor-toolbar').offsetHeight;
        const statusBarHeight = document.getElementById('status-bar').offsetHeight;
        document.documentElement.style.setProperty('--toolbar-height', `${editorToolbarHeight}px`);
        document.documentElement.style.setProperty('--status-bar-height', `${statusBarHeight}px`);

        // Initialize status bar
        updateErrorStatus();
        updateWordCharCount();
        updateCursorPosition(); // Initial cursor position

        // Hide loading spinner and show app
        loadingOverlay.classList.add('hidden');
        app.classList.add('loaded');
      }

      // --- Cache Storage Functions ---
      async function saveToCache(content, showUserToast = true) {
        try {
          const cache = await caches.open(CACHE_NAME);
          const response = new Response(content, {
            headers: { 'Content-Type': 'text/plain' }
          });
          await cache.put(CACHE_KEY, response);
          if (showUserToast) {
            showToast('Content saved to Arbo Editor cache!', 'success');
          }
        } catch (err) {
          console.error('Cache save error:', err);
          showToast('Failed to save to Arbo Editor cache. Check console for details.', 'error');
        }
      }

      async function loadFromCache() {
        try {
          const cache = await caches.open(CACHE_NAME);
          const response = await cache.match(CACHE_KEY);
          if (response) {
            return await response.text();
          }
          return null; // Return null if not found
        } catch (err) {
          console.error('Cache load error:', err);
          // Fallback to localStorage or default if cache fails
          return null;
        }
      }

      // --- Utility Functions ---
      let toastTimeout;
      /**
       * Displays a toast notification.
       * @param {string} message - The message to display.
       * @param {'success'|'error'|'info'} type - The type of toast (affects color).
       */
      function showToast(message, type = 'info') {
        const toast = document.getElementById('toast-message');
        clearTimeout(toastTimeout); // Clear any existing toast timeout to prevent stacking issues
        toast.textContent = message;
        toast.className = `toast show ${type}`; // Reset classes and add new ones
        toastTimeout = setTimeout(() => {
          toast.classList.remove('show');
        }, 2000); // 2 seconds
      }

      let keyLogTimeout;
      /**
       * Displays the last pressed key briefly.
       * @param {string} key - The key pressed.
       */
      function showKeyLog(key) {
        const keyLogDisplay = document.getElementById('key-logging-display');
        clearTimeout(keyLogTimeout); // Clear any existing key log timeout
        keyLogDisplay.textContent = `Key: "${key}"`;
        keyLogDisplay.classList.add('show-key-log');
        keyLogTimeout = setTimeout(() => {
          keyLogDisplay.classList.remove('show-key-log');
        }, 300); // 300 milliseconds duration
      }

      /**
       * Debounces a function call.
       * @param {Function} func - The function to debounce.
       * @param {number} wait - The delay in milliseconds.
       * @returns {Function} The debounced function.
       */
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      /**
       * Gets file extension for a given Monaco language ID.
       * @param {string} lang - Monaco language ID.
       * @returns {string} The common file extension.
       */
      function getExtensionForLanguage(lang) {
        const extensions = {
          javascript: 'js', typescript: 'ts', html: 'html', css: 'css', json: 'json',
          python: 'py', java: 'java', csharp: 'cs', php: 'php', markdown: 'md',
          xml: 'xml', ruby: 'rb', go: 'go', swift: 'swift', kotlin: 'kt',
          rust: 'rs', sql: 'sql', yaml: 'yml', toml: 'toml', powershell: 'ps1',
          dockerfile: 'dockerfile', cpp: 'cpp', c: 'c', 'objective-c': 'm',
          perl: 'pl', r: 'r', sh: 'sh', plaintext: 'txt'
        };
        return extensions[lang] || 'txt';
      }

      /**
       * Gets Monaco language ID for a given file extension.
       * @param {string} ext - The file extension.
       * @returns {string} The corresponding Monaco language ID.
       */
      function getLanguageFromExtension(ext) {
        const languages = {
          js: 'javascript', ts: 'typescript', html: 'html', css: 'css', json: 'json',
          py: 'python', java: 'java', cs: 'csharp', php: 'php', md: 'markdown',
          xml: 'xml', rb: 'ruby', go: 'go', swift: 'swift', kt: 'kotlin',
          rs: 'rust', sql: 'sql', yml: 'yaml', yaml: 'yaml', toml: 'toml',
          ps1: 'powershell', dockerfile: 'dockerfile', cpp: 'cpp', cxx: 'cpp',
          hpp: 'cpp', c: 'c', h: 'c', m: 'objective-c', mm: 'objective-c',
          pl: 'perl', r: 'r', sh: 'shell', bash: 'shell', txt: 'plaintext'
        };
        return languages[ext.toLowerCase()] || 'plaintext';
      }

      /**
       * Checks if a language has a formatter available.
       * @param {string} languageId - The Monaco language ID.
       * @returns {boolean} True if formatting is supported, false otherwise.
       */
      async function canFormatLanguage(languageId) {
        // Monaco's formatters are usually available synchronous after language is loaded,
        // but using a promise ensures it handles async loading if any.
        const formatters = monaco.languages.getLanguages().find(lang => lang.id === languageId)?.languageFeatures.documentFormattingEditProvider;
        return !!formatters;
      }

      // --- Custom Modals ---
      const customAlertModalOverlay = document.getElementById('custom-alert-modal-overlay');
      const alertModalTitle = document.getElementById('alert-modal-title');
      const alertModalMessage = document.getElementById('alert-modal-message');
      const alertModalOkBtn = document.getElementById('alert-modal-ok-btn');

      /**
       * Shows a custom alert modal.
       * @param {string} title - The title of the alert.
       * @param {string} message - The message of the alert.
       * @returns {Promise<void>} A promise that resolves when the alert is closed.
       */
      function showAlert(title, message) {
        return new Promise(resolve => {
          alertModalTitle.textContent = title;
          alertModalMessage.textContent = message;
          customAlertModalOverlay.classList.add('visible');
          alertModalOkBtn.focus(); // Focus the OK button for accessibility

          const cleanup = () => {
            customAlertModalOverlay.classList.remove('visible');
            alertModalOkBtn.removeEventListener('click', onClick);
            document.removeEventListener('keydown', onKeydown);
            resolve();
          };

          const onClick = () => cleanup();
          const onKeydown = (e) => {
            if (e.key === 'Enter' || e.key === 'Escape') {
              cleanup();
            }
          };

          alertModalOkBtn.addEventListener('click', onClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      const customConfirmModalOverlay = document.getElementById('custom-confirm-modal-overlay');
      const confirmModalTitle = document.getElementById('confirm-modal-title');
      const confirmModalMessage = document.getElementById('confirm-modal-message');
      const confirmModalConfirmBtn = document.getElementById('confirm-modal-confirm-btn');
      const confirmModalCancelBtn = document.getElementById('confirm-modal-cancel-btn');

      /**
       * Shows a custom confirmation modal.
       * @param {string} title - The title of the confirmation.
       * @param {string} message - The message of the confirmation.
       * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false if cancelled.
       */
      function showConfirm(title, message) {
        return new Promise(resolve => {
          confirmModalTitle.textContent = title;
          confirmModalMessage.textContent = message;
          customConfirmModalOverlay.classList.add('visible');
          confirmModalConfirmBtn.focus(); // Focus confirm button by default

          const cleanup = (result) => {
            customConfirmModalOverlay.classList.remove('visible');
            confirmModalConfirmBtn.removeEventListener('click', onConfirmClick);
            confirmModalCancelBtn.removeEventListener('click', onCancelClick);
            document.removeEventListener('keydown', onKeydown);
            resolve(result);
          };

          const onConfirmClick = () => cleanup(true);
          const onCancelClick = () => cleanup(false);
          const onKeydown = (e) => {
            if (e.key === 'Enter') {
              cleanup(true);
            } else if (e.key === 'Escape') {
              cleanup(false);
            }
          };

          confirmModalConfirmBtn.addEventListener('click', onConfirmClick);
          confirmModalCancelBtn.addEventListener('click', onCancelClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      const customPromptModalOverlay = document.getElementById('custom-prompt-modal-overlay');
      const promptModalTitle = document.getElementById('prompt-modal-title');
      const promptModalMessage = document.getElementById('prompt-modal-message');
      const promptModalInput = document.getElementById('prompt-modal-input');
      const promptModalConfirmBtn = document.getElementById('prompt-modal-confirm-btn');
      const promptModalCancelBtn = document.getElementById('prompt-modal-cancel-btn');

      /**
       * Shows a custom prompt modal.
       * @param {string} title - The title of the prompt.
       * @param {string} message - The message of the prompt.
       * @param {string} [defaultValue=''] - The default value for the input.
       * @returns {Promise<string|null>} A promise that resolves to the input value if submitted, null if cancelled.
       */
      function showPrompt(title, message, defaultValue = '') {
        return new Promise(resolve => {
          promptModalTitle.textContent = title;
          promptModalMessage.textContent = message;
          promptModalInput.value = defaultValue;
          customPromptModalOverlay.classList.add('visible');
          promptModalInput.focus(); // Focus input field

          // Select all text in the input field on focus
          promptModalInput.select(); 
          
          const cleanup = (result) => {
            customPromptModalOverlay.classList.remove('visible');
            promptModalConfirmBtn.removeEventListener('click', onConfirmClick);
            promptModalCancelBtn.removeEventListener('click', onCancelClick);
            document.removeEventListener('keydown', onKeydown);
            resolve(result);
          };

          const onConfirmClick = () => cleanup(promptModalInput.value);
          const onCancelClick = () => cleanup(null);
          const onKeydown = (e) => {
            if (e.key === 'Enter') {
              cleanup(promptModalInput.value);
            } else if (e.key === 'Escape') {
              cleanup(null);
            }
          };

          promptModalConfirmBtn.addEventListener('click', onConfirmClick);
          promptModalCancelBtn.addEventListener('click', onCancelClick);
          document.addEventListener('keydown', onKeydown);
        });
      }

      // --- Status Bar Updates ---
      function updateErrorStatus() {
        const model = editorInstance.getModel();
        // Get all markers, not just errors
        const markers = monaco.editor.getModelMarkers({ resource: model.uri });
        const errorCount = markers.filter(marker => marker.severity === monaco.MarkerSeverity.Error).length;
        const errorStatusDisplay = document.getElementById('error-status');
        if (errorCount > 0) {
          errorStatusDisplay.style.display = 'inline-flex';
          errorStatusDisplay.innerHTML = `<span class="codicon codicon-error" aria-hidden="true"></span> Errors: ${errorCount}`;
        } else {
          errorStatusDisplay.style.display = 'none'; // Hide if no errors
        }
      }

      const updateWordCharCount = debounce(() => {
        const text = editorInstance.getValue();
        const charCount = text.length;
        // Split by any whitespace, filter empty strings from multiple spaces
        const wordCount = text.trim().split(/\s+/).filter(word => word.length > 0).length;
        document.getElementById('word-char-count').innerHTML = `<span class="codicon codicon-text-size" aria-hidden="true"></span> Words: ${wordCount} | Chars: ${charCount}`;
      }, 300); // Debounce to avoid frequent updates

      function updateCursorPosition() {
        const pos = editorInstance.getPosition();
        if (pos) { // Ensure position exists before accessing
          document.getElementById('cursor-pos').textContent = `Ln ${pos.lineNumber}, Col ${pos.column}`;
        }
      }

      // --- Event Handlers ---
      function setupEventListeners() {
        const app = document.getElementById('app');
        const editorContainer = document.getElementById('editor-container');
        const maximizeMinimizeBtn = document.getElementById('maximize-minimize-btn');
        const maximizeMinimizeIcon = maximizeMinimizeBtn.querySelector('.codicon');
        const sidebar = document.getElementById('sidebar');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn'); // Get the new button

        // Maximize/Minimize Button
        maximizeMinimizeBtn.addEventListener('click', () => {
            isMaximized = !isMaximized;
            
            app.classList.toggle('maximized-editor', isMaximized);
            sidebar.classList.toggle('hidden', isMaximized); // Hide sidebar smoothly
            
            // Update icon and provide toast feedback
            if (isMaximized) {
                maximizeMinimizeIcon.classList.remove('codicon-screen-full');
                maximizeMinimizeIcon.classList.add('codicon-screen-normal');
                showToast('Arbo Editor maximized.', 'info');
            } else {
                maximizeMinimizeIcon.classList.remove('codicon-screen-normal');
                maximizeMinimizeIcon.classList.add('codicon-screen-full');
                showToast('Arbo Editor minimized.', 'info');
            }

            // Important: Force layout of both editors after size change
            editorInstance.layout();
            if (diffEditorInstance) { // Ensure diff editor exists before trying to layout
                diffEditorInstance.layout();
            }
        });

        // Toggle Sidebar Button
        toggleSidebarBtn.addEventListener('click', () => {
            isSidebarCollapsed = !isSidebarCollapsed;
            sidebar.classList.toggle('collapsed', isSidebarCollapsed);
            
            // Re-layout editor(s) after sidebar size change
            editorInstance.layout();
            if (diffEditorInstance) {
                diffEditorInstance.layout();
            }

            showToast(`Sidebar ${isSidebarCollapsed ? 'Collapsed' : 'Expanded'}`, 'info');
        });


        // Language Selection
        const languageSelect = document.getElementById('language-select');
        const langDisplay = document.getElementById('lang-display');
        languageSelect.addEventListener('change', (event) => {
          currentLanguage = event.target.value;
          monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
          if (originalModel) { // Update original model language too for consistent diff view
            monaco.editor.setModelLanguage(originalModel, currentLanguage);
          }
          langDisplay.textContent = currentLanguage;
          localStorage.setItem('arboEditorLanguage', currentLanguage);
          updateErrorStatus(); // Update error status for new language
          showToast(`Arbo Editor language set to ${currentLanguage.toUpperCase()}`, 'info');
          updateFormatButtonState(); // Update format button state for the new language
        });

        // Font Size Adjustment
        const fontSizeSelect = document.getElementById('font-size-select');
        fontSizeSelect.addEventListener('change', (event) => {
          const newSize = parseInt(event.target.value);
          editorInstance.updateOptions({ fontSize: newSize });
          if (diffEditorInstance) { // Apply to diff editor as well
            diffEditorInstance.getOriginalEditor().updateOptions({ fontSize: newSize });
            diffEditorInstance.getModifiedEditor().updateOptions({ fontSize: newSize });
          }
          localStorage.setItem('arboEditorFontSize', newSize);
          showToast(`Arbo Editor font size set to ${newSize}px`, 'info');
        });

        // Theme Toggling
        document.getElementById('theme-toggle-btn').addEventListener('click', () => {
          currentTheme = currentTheme === 'vs-dark' ? 'vs-light' : 'vs-dark';
          monaco.editor.setTheme(currentTheme);
          if (diffEditorInstance) { // Apply to diff editor as well
            diffEditorInstance.getOriginalEditor().updateOptions({ theme: currentTheme });
            diffEditorInstance.getModifiedEditor().updateOptions({ theme: currentTheme });
          }
          localStorage.setItem('arboEditorTheme', currentTheme);
          document.getElementById('theme-toggle-btn').classList.toggle('active', currentTheme === 'vs-dark');
          showToast(`Arbo Editor switched to ${currentTheme === 'vs-dark' ? 'Dark' : 'Light'} Theme`, 'info');
        });

        // Word Wrap Toggling
        document.getElementById('toggle-word-wrap-btn').addEventListener('click', () => {
          isWordWrapEnabled = !isWordWrapEnabled;
          editorInstance.updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
          if (diffEditorInstance) { // Apply to diff editor as well
            diffEditorInstance.getOriginalEditor().updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
            diffEditorInstance.getModifiedEditor().updateOptions({ wordWrap: isWordWrapEnabled ? 'on' : 'off' });
          }
          localStorage.setItem('arboEditorWordWrap', isWordWrapEnabled);
          document.getElementById('toggle-word-wrap-btn').classList.toggle('active', isWordWrapEnabled);
          showToast(`Arbo Editor Word Wrap ${isWordWrapEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Undo/Redo
        document.getElementById('undo-btn').addEventListener('click', () => {
          // Trigger actions only if editor is not in read-only mode
          if (!isReadOnlyMode) {
              editorInstance.trigger('source', 'undo', {});
              showToast('Arbo Editor Undo performed', 'info');
          } else {
              showToast('Cannot undo in read-only mode.', 'info');
          }
        });

        document.getElementById('redo-btn').addEventListener('click', () => {
          // Trigger actions only if editor is not in read-only mode
          if (!isReadOnlyMode) {
              editorInstance.trigger('source', 'redo', {});
              showToast('Arbo Editor Redo performed', 'info');
          } else {
              showToast('Cannot redo in read-only mode.', 'info');
          }
        });

        // Cursor Navigation (Ensuring focus after movement)
        document.getElementById('cursor-up-btn').addEventListener('click', () => {
            editorInstance.trigger('keyboard', 'cursorUp', {});
            editorInstance.focus(); // Keep editor focused
        });
        document.getElementById('cursor-down-btn').addEventListener('click', () => {
            editorInstance.trigger('keyboard', 'cursorDown', {});
            editorInstance.focus();
        });
        document.getElementById('cursor-left-btn').addEventListener('click', () => {
            editorInstance.trigger('keyboard', 'cursorLeft', {});
            editorInstance.focus();
        });
        document.getElementById('cursor-right-btn').addEventListener('click', () => {
            editorInstance.trigger('keyboard', 'cursorRight', {});
            editorInstance.focus();
        });


        // Editor Status Updates
        editorInstance.onDidChangeCursorPosition(updateCursorPosition); // Update on cursor change

        const debounceSaveToCacheOnContentChange = debounce(async () => {
            const currentContent = editorInstance.getValue();
            // Only save if content has actually changed since last autosave
            if (currentContent !== lastAutosaveContent) {
                await saveToCache(currentContent, false); // Don't show toast for autosave
                lastAutosaveContent = currentContent; // Update last autosaved content
            }
        }, 1000); // Auto-save every 1 second after last change

        editorInstance.onDidChangeModelContent(() => {
          updateErrorStatus();
          updateWordCharCount();
          debounceSaveToCacheOnContentChange();
          // Update original model content only if it's the same model as the current one
          // This prevents accidental overwrites if models are switched (e.g., in diff view)
          if (originalModel && editorInstance.getModel() === originalModel) {
            originalModel.setValue(editorInstance.getValue());
          }
          updateFormatButtonState(); // Update format button accessibility dynamically
        });

        // New File
        document.getElementById('new-file-btn').addEventListener('click', async () => {
          // Prompt for confirmation to prevent accidental data loss
          const confirmed = await showConfirm('New File in Arbo Editor', 'Are you sure you want to create a new file? Any unsaved changes will be lost.');
          if (confirmed) {
            editorInstance.setValue('');
            if (originalModel) { // Ensure originalModel exists before updating
              originalModel.setValue('');
            }
            currentLanguage = 'plaintext'; // Reset language to plaintext for a new file
            monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
            languageSelect.value = currentLanguage;
            langDisplay.textContent = currentLanguage;
            localStorage.setItem('arboEditorLanguage', currentLanguage); // Persist language choice
            await saveToCache(''); // Save empty content to cache
            lastAutosaveContent = ''; // Reset last autosave content
            showToast('New file created in Arbo Editor!', 'success');
            updateFormatButtonState();
          } else {
            showToast('New file creation cancelled in Arbo Editor.', 'info');
          }
        });

        // Clear Editor
        document.getElementById('clear-editor-btn').addEventListener('click', async () => {
          const confirmed = await showConfirm('Clear Arbo Editor', 'Are you sure you want to clear the Arbo Editor content? This action cannot be undone.');
          if (confirmed) {
            editorInstance.setValue('');
            if (originalModel) { // Ensure originalModel exists before updating
              originalModel.setValue('');
            }
            await saveToCache(''); // Save empty content to cache
            lastAutosaveContent = ''; // Reset last autosave content
            showToast('Arbo Editor content cleared!', 'success');
            updateFormatButtonState();
          } else {
            showToast('Clear Arbo Editor cancelled.', 'info');
          }
        });

        // Save to Cache (explicit save)
        document.getElementById('save-cache-btn').addEventListener('click', async () => {
          const content = editorInstance.getValue();
          await saveToCache(content, true); // Show toast for explicit save
          if (originalModel) {
              originalModel.setValue(content); // Update original model to match current
          }
          lastAutosaveContent = content; // Update last autosaved content
        });

        // Download Code
        document.getElementById('download-btn').addEventListener('click', async () => {
          const code = editorInstance.getValue();
          // Provide a sensible default filename
          const defaultFileName = `untitled.${getExtensionForLanguage(currentLanguage)}`;
          const fileName = await showPrompt('Download Code from Arbo Editor', 'Enter desired file name:', defaultFileName);
          if (fileName) { // Only proceed if a filename was provided (not null from cancel)
            try {
              const blob = new Blob([code], { type: 'text/plain' }); // Using 'text/plain' as a generic fallback
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = fileName; // Set the user-provided filename
              document.body.appendChild(a); // Append to body to make it clickable
              a.click(); // Trigger download
              document.body.removeChild(a); // Clean up
              URL.revokeObjectURL(url); // Release object URL
              showToast(`File "${fileName}" downloaded from Arbo Editor!`, 'success');
            } catch (err) {
              console.error('Download error:', err);
              showToast('Failed to download file from Arbo Editor.', 'error');
            }
          } else {
            showToast('Download cancelled in Arbo Editor.', 'info');
          }
        });

        // Open File
        document.getElementById('open-file-btn').addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'file';
          // Define a comprehensive list of accepted file types and their extensions
          input.accept = '.js,.ts,.html,.css,.json,.py,.java,.cs,.php,.md,.xml,.rb,.go,.swift,.kt,.rs,.sql,.yml,.toml,.ps1,.dockerfile,.c,.cpp,.m,.pl,.r,.sh,.txt,text/*,application/json';
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
              // Confirm before opening a new file to prevent data loss
              const confirmed = await showConfirm('Open File in Arbo Editor', `Opening "${file.name}" will replace current editor content. Continue?`);
              if (!confirmed) {
                  showToast('File open cancelled in Arbo Editor.', 'info');
                  return;
              }

              try {
                const reader = new FileReader();
                reader.onload = async function(event) {
                  const fileContent = event.target.result;
                  editorInstance.setValue(fileContent);
                  originalModel.setValue(fileContent); // Update original model for diff
                  lastAutosaveContent = fileContent; // Update last autosave content

                  const fileNameParts = file.name.split('.');
                  const fileExtension = fileNameParts.length > 1 ? fileNameParts.pop().toLowerCase() : 'txt'; // Handle files without extension
                  
                  const detectedLanguage = getLanguageFromExtension(fileExtension);
                  
                  // Check if the detected language is supported by Monaco Editor
                  const supportedLanguages = monaco.languages.getLanguages().map(lang => lang.id);
                  if (supportedLanguages.includes(detectedLanguage)) {
                    currentLanguage = detectedLanguage;
                    monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
                    monaco.editor.setModelLanguage(originalModel, currentLanguage);
                    languageSelect.value = currentLanguage;
                    langDisplay.textContent = currentLanguage;
                    localStorage.setItem('arboEditorLanguage', currentLanguage);
                    await saveToCache(fileContent); // Auto-save opened file to cache
                    showToast(`Opened "${file.name}" in Arbo Editor as ${currentLanguage.toUpperCase()}`, 'success');
                  } else {
                    currentLanguage = 'plaintext'; // Fallback to plaintext
                    monaco.editor.setModelLanguage(editorInstance.getModel(), currentLanguage);
                    monaco.editor.setModelLanguage(originalModel, currentLanguage);
                    languageSelect.value = currentLanguage;
                    langDisplay.textContent = currentLanguage;
                    localStorage.setItem('arboEditorLanguage', currentLanguage);
                    await saveToCache(fileContent); // Auto-save opened file to cache
                    showToast(`Opened "${file.name}" in Arbo Editor (language not detected, set to Plain Text)`, 'info');
                  }
                  updateFormatButtonState(); // Update format button for the new language
                };
                reader.onerror = () => {
                  showToast('Failed to read file in Arbo Editor. Check file permissions.', 'error');
                };
                reader.readAsText(file);
              } catch (err) {
                showToast('Error opening file in Arbo Editor. Check console for details.', 'error');
                console.error('File open error:', err);
              }
            } else {
                showToast('No file selected to open in Arbo Editor.', 'info');
            }
          };
          input.click(); // Programmatically click the hidden file input
        });

        // Enhanced Code Formatting
        const formatCodeBtn = document.getElementById('format-code-btn');
        /**
         * Updates the disabled state of the format buttons based on language support and selection.
         */
        async function updateFormatButtonState() {
            const isFormatEnabled = await canFormatLanguage(currentLanguage);
            formatCodeBtn.disabled = !isFormatEnabled || isReadOnlyMode;
            // Context menu format button is disabled if no selection OR not supported OR read-only
            contextFormatBtn.disabled = !isFormatEnabled || editorInstance.getSelection().isEmpty() || isReadOnlyMode;
        }

        formatCodeBtn.addEventListener('click', async () => {
          if (isReadOnlyMode) {
            showToast('Cannot format code in read-only mode.', 'info');
            return;
          }
          try {
            if (await canFormatLanguage(currentLanguage)) {
              showToast('Formatting code in Arbo Editor...', 'info');
              await editorInstance.getAction('editor.action.formatDocument').run();
              showToast('Code formatted successfully in Arbo Editor!', 'success');
            } else {
              showToast('Formatting not supported for this language in Arbo Editor.', 'info');
            }
          } catch (err) {
            console.error('Formatting error in Arbo Editor:', err);
            showToast('Failed to format code in Arbo Editor. See console for details.', 'error');
          }
        });
        updateFormatButtonState(); // Call initially to set correct state

        // Context Menu
        const customContextMenu = document.getElementById('custom-context-menu');
        const contextCopyBtn = document.getElementById('context-copy-btn');
        const contextPasteBtn = document.getElementById('context-paste-btn');
        const contextCutBtn = document.getElementById('context-cut-btn');
        const contextSelectAllBtn = document.getElementById('context-select-all-btn');
        const contextFormatBtn = document.getElementById('context-format-btn');
        const editorContainerDiv = document.getElementById('container');

        let touchTimer;
        const LONG_PRESS_THRESHOLD = 500; // milliseconds

        // Handle touchstart for long press to show context menu
        editorContainerDiv.addEventListener('touchstart', (e) => {
          // Only trigger for single touch
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            let startX = touch.clientX;
            let startY = touch.clientY;
            touchTimer = setTimeout(() => {
              // Check if touch hasn't moved significantly
              if (Math.abs(touch.clientX - startX) < 10 && Math.abs(touch.clientY - startY) < 10) {
                e.preventDefault(); // Prevent default browser context menu/selection
                showContextMenu(touch.clientX, touch.clientY);
              }
            }, LONG_PRESS_THRESHOLD);
          }
        }, { passive: false }); // Use passive: false to allow preventDefault

        editorContainerDiv.addEventListener('touchmove', () => {
          clearTimeout(touchTimer); // Cancel long press if finger moves
        });

        editorContainerDiv.addEventListener('touchend', () => {
          clearTimeout(touchTimer); // Cancel long press if finger is lifted
        });

        // Native Monaco Context Menu override
        editorInstance.onContextMenu((e) => {
          e.event.preventDefault(); // Prevent Monaco's default context menu
          showContextMenu(e.event.clientX, e.event.clientY);
        });

        /**
         * Shows the custom context menu at specified coordinates.
         * @param {number} x - ClientX coordinate.
         * @param {number} y - ClientY coordinate.
         */
        function showContextMenu(x, y) {
          const selection = editorInstance.getSelection();
          const hasSelection = !selection.isEmpty();
          // Disable/enable context menu items based on selection and read-only mode
          contextCopyBtn.disabled = !hasSelection;
          contextCutBtn.disabled = !hasSelection || isReadOnlyMode;
          contextPasteBtn.disabled = isReadOnlyMode;
          contextFormatBtn.disabled = !hasSelection || !(canFormatLanguage(currentLanguage)) || isReadOnlyMode;

          customContextMenu.classList.add('show');
          customContextMenu.setAttribute('aria-hidden', 'false');

          let finalX = x;
          let finalY = y;
          const menuWidth = customContextMenu.offsetWidth;
          const menuHeight = customContextMenu.offsetHeight;

          // Adjust position to keep it within viewport, considering potential CSS scaling on mobile
          const scaleFactor = getComputedStyle(document.body).transform !== 'none' ? parseFloat(getComputedStyle(document.body).transform.split(',')[0].slice(7)) : 1;
          const viewportWidth = window.innerWidth / scaleFactor;
          const viewportHeight = window.innerHeight / scaleFactor;

          if ((x / scaleFactor) + menuWidth > viewportWidth - 10) {
            finalX = (viewportWidth - menuWidth - 10) * scaleFactor;
          }
          if ((y / scaleFactor) + menuHeight > viewportHeight - 10) {
            finalY = (viewportHeight - menuHeight - 10) * scaleFactor;
          }

          customContextMenu.style.left = `${Math.max(0, finalX)}px`;
          customContextMenu.style.top = `${Math.max(0, finalY)}px`;
          // Focus the first actionable button for keyboard navigation
          contextCopyBtn.focus();
        }

        // Context Menu Keyboard Navigation
        const contextButtons = [contextCopyBtn, contextPasteBtn, contextCutBtn, contextFormatBtn, contextSelectAllBtn];
        contextButtons.forEach((btn, index) => {
          btn.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              let nextIndex = (index + 1) % contextButtons.length;
              // Skip disabled buttons when navigating
              while (contextButtons[nextIndex].disabled && nextIndex !== index) {
                  nextIndex = (nextIndex + 1) % contextButtons.length;
              }
              contextButtons[nextIndex].focus();
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              let prevIndex = (index - 1 + contextButtons.length) % contextButtons.length;
              // Skip disabled buttons when navigating
              while (contextButtons[prevIndex].disabled && prevIndex !== index) {
                  prevIndex = (prevIndex - 1 + contextButtons.length) % contextButtons.length;
              }
              contextButtons[prevIndex].focus();
            } else if (e.key === 'Escape') {
              hideContextMenu();
              editorInstance.focus(); // Return focus to editor
            }
          });
        });

        /**
         * Hides the custom context menu.
         */
        function hideContextMenu() {
            customContextMenu.classList.remove('show');
            customContextMenu.setAttribute('aria-hidden', 'true');
        }

        // Hide context menu when clicking outside
        document.addEventListener('click', (e) => {
          // If the click is not inside the context menu AND not inside the editor
          if (!customContextMenu.contains(e.target) && !editorContainerDiv.contains(e.target)) {
            hideContextMenu();
          }
        });

        // Handle 'focusout' from context menu buttons to hide the menu
        customContextMenu.addEventListener('focusout', (e) => {
            // Hide if the new focus target is outside the context menu
            if (!customContextMenu.contains(e.relatedTarget)) {
                hideContextMenu();
            }
        });


        /**
         * Copies the currently selected text to the clipboard.
         */
        async function copySelectedText() {
          const selectedText = editorInstance.getModel().getValueInRange(editorInstance.getSelection());
          if (selectedText && selectedText.length > 0) { // Ensure there's actual text
            try {
              await navigator.clipboard.writeText(selectedText);
              showToast('Text copied to clipboard from Arbo Editor!', 'success');
            } catch (err) {
              console.error('Failed to copy text in Arbo Editor:', err);
              // Provide user-friendly message for permission issues
              showToast('Failed to copy text. Please grant clipboard permissions to Arbo Editor.', 'error');
            }
          } else {
            showToast('No text selected to copy in Arbo Editor.', 'info');
          }
        }

        /**
         * Pastes text from the clipboard into the editor.
         */
        async function pasteText() {
          if (isReadOnlyMode) {
            showToast('Cannot paste in read-only mode in Arbo Editor.', 'info');
            return;
          }
          try {
            const text = await navigator.clipboard.readText();
            if (text) { // Only paste if there's text in clipboard
                editorInstance.trigger('source', 'paste', { text });
                showToast('Text pasted in Arbo Editor!', 'success');
            } else {
                showToast('Clipboard is empty, nothing to paste.', 'info');
            }
          } catch (err) {
              console.error('Failed to paste text in Arbo Editor:', err);
              showToast('Failed to paste text. Please grant clipboard permissions to Arbo Editor.', 'error');
          }
        }

        /**
         * Cuts the currently selected text to the clipboard.
         */
        async function cutSelectedText() {
          if (isReadOnlyMode) {
            showToast('Cannot cut in read-only mode in Arbo Editor.', 'info');
            return;
          }
          const selectedText = editorInstance.getModel().getValueInRange(editorInstance.getSelection());
          if (selectedText && selectedText.length > 0) { // Ensure there's actual text
            try {
              await navigator.clipboard.writeText(selectedText);
              editorInstance.trigger('source', 'cut'); // Monaco's cut action
              showToast('Text cut to clipboard from Arbo Editor!', 'success');
            } catch (err) {
              console.error('Failed to cut text in Arbo Editor:', err);
              showToast('Failed to cut text. Please grant clipboard permissions to Arbo Editor.', 'error');
            }
          } else {
            showToast('No text selected to cut in Arbo Editor.', 'info');
          }
        }

        contextCopyBtn.addEventListener('click', () => {
          copySelectedText();
          hideContextMenu();
        });

        contextPasteBtn.addEventListener('click', () => {
          pasteText();
          hideContextMenu();
        });

        contextCutBtn.addEventListener('click', () => {
          cutSelectedText();
          hideContextMenu();
        });

        contextFormatBtn.addEventListener('click', async () => {
          if (isReadOnlyMode) {
            showToast('Cannot format code in read-only mode.', 'info');
            hideContextMenu();
            return;
          }
          const selection = editorInstance.getSelection();
          try {
            if (await canFormatLanguage(currentLanguage)) {
              if (!selection.isEmpty()) {
                showToast('Formatting selection in Arbo Editor...', 'info');
                await editorInstance.getAction('editor.action.formatSelection').run();
                showToast('Selected code formatted in Arbo Editor!', 'success');
              } else {
                showToast('Formatting document in Arbo Editor...', 'info');
                await editorInstance.getAction('editor.action.formatDocument').run();
                showToast('Code formatted in Arbo Editor!', 'success');
              }
            } else {
              showToast('Formatting not supported for this language in Arbo Editor.', 'info');
            }
          } catch (err) {
            console.error('Formatting error in Arbo Editor:', err);
            showToast('Failed to format code in Arbo Editor. See console for details.', 'error');
          }
          hideContextMenu();
        });

        contextSelectAllBtn.addEventListener('click', () => {
          editorInstance.setSelection(editorInstance.getModel().getFullModelRange());
          editorInstance.focus(); // Ensure editor is focused after selecting all
          hideContextMenu();
          showToast('All text selected in Arbo Editor.', 'info');
        });

        document.getElementById('copy-all-btn').addEventListener('click', async () => {
          const allText = editorInstance.getValue();
          if (allText && allText.length > 0) { // Check if editor content is not empty
            try {
              await navigator.clipboard.writeText(allText);
              showToast('All code copied to clipboard from Arbo Editor!', 'success');
            } catch (err) {
              console.error('Failed to copy all text in Arbo Editor:', err);
              showToast('Failed to copy all text. Please grant clipboard permissions to Arbo Editor.', 'error');
            }
          } else {
            showToast('Arbo Editor is empty, nothing to copy.', 'info');
          }
        });

        // Find/Replace: Trigger Monaco's built-in find widget
        document.getElementById('find-replace-btn').addEventListener('click', () => {
          // Check if the editor is in read-only mode. Find is allowed, replace is not.
          // Monaco's find widget internally handles read-only mode for replace functionality.
          editorInstance.getAction('actions.find').run();
          showToast('Arbo Editor Find/Replace opened.', 'info');
        });

        // Diff View
        const diffContainer = document.getElementById('diff-container');
        const mainEditorContainer = document.getElementById('editor-container');
        const diffEditorDiv = document.getElementById('diff-editor');

        document.getElementById('diff-view-btn').addEventListener('click', () => {
          mainEditorContainer.style.display = 'none'; // Hide main editor
          diffContainer.classList.add('show'); // Show diff container

          // Initialize diff editor only once, if not already created
          if (!diffEditorInstance) {
            diffEditorInstance = monaco.editor.createDiffEditor(diffEditorDiv, {
              theme: currentTheme,
              automaticLayout: true,
              readOnly: true, // Original side is always read-only
              scrollBeyondLastLine: false,
              fontSize: editorInstance.getOptions().get(monaco.editor.EditorOption.fontSize),
              wordWrap: isWordWrapEnabled ? 'on' : 'off',
              minimap: { enabled: isMinimapEnabled },
              lineNumbers: areLineNumbersEnabled ? 'on' : 'off',
              folding: true,
              smoothScrolling: true,
              mouseWheelScrollSensitivity: 2.0
            });
          }

          // Set read-only state for the modified editor in diff view based on main editor's state
          diffEditorInstance.getModifiedEditor().updateOptions({ readOnly: isReadOnlyMode });

          // Ensure originalModel always reflects the state before current edits for meaningful diffs
          originalModel.setValue(lastAutosaveContent); // Use last auto-saved content as original
          monaco.editor.setModelLanguage(originalModel, currentLanguage); // Ensure correct language for original model

          diffEditorInstance.setModel({
            original: originalModel,
            modified: editorInstance.getModel()
          });

          diffEditorInstance.layout(); // Layout after setting models
          showToast('Arbo Editor Diff view enabled.', 'info');
          diffEditorInstance.getModifiedEditor().focus(); // Focus the modified side for potential edits
        });

        document.getElementById('close-diff-btn').addEventListener('click', () => {
          diffContainer.classList.remove('show');
          // Use a timeout to allow transition to complete before changing display
          setTimeout(() => {
            mainEditorContainer.style.display = 'flex'; // Show main editor again
            editorInstance.layout(); // Layout main editor
            editorInstance.focus(); // Focus main editor
            showToast('Arbo Editor Diff view closed.', 'info');
          }, 300); // Match CSS transition duration
        });

        document.getElementById('accept-changes-btn').addEventListener('click', async () => {
          if (diffEditorInstance) {
            if (isReadOnlyMode) {
                showToast('Cannot accept changes in read-only mode.', 'info');
                return;
            }
            const modifiedContent = diffEditorInstance.getModifiedEditor().getValue();
            editorInstance.setValue(modifiedContent); // Update main editor
            originalModel.setValue(modifiedContent); // Update original model to match
            lastAutosaveContent = modifiedContent; // Update last autosaved content
            await saveToCache(modifiedContent); // Save changes to cache
            showToast('Changes accepted from Arbo Editor diff view!', 'success');

            diffContainer.classList.remove('show');
            setTimeout(() => {
                mainEditorContainer.style.display = 'flex';
                editorInstance.layout();
                editorInstance.focus();
            }, 300);
          } else {
              showToast('No active diff view to accept changes from.', 'error');
          }
        });

        // Toggle Minimap
        document.getElementById('toggle-minimap-btn').addEventListener('click', () => {
          isMinimapEnabled = !isMinimapEnabled;
          editorInstance.updateOptions({ minimap: { enabled: isMinimapEnabled } });
          if (diffEditorInstance) { // Apply to diff editor as well
            diffEditorInstance.getOriginalEditor().updateOptions({ minimap: { enabled: isMinimapEnabled } });
            diffEditorInstance.getModifiedEditor().updateOptions({ minimap: { enabled: isMinimapEnabled } });
          }
          localStorage.setItem('arboEditorMinimap', isMinimapEnabled);
          document.getElementById('toggle-minimap-btn').classList.toggle('active', isMinimapEnabled);
          showToast(`Arbo Editor Minimap ${isMinimapEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Toggle Line Numbers
        document.getElementById('toggle-line-numbers-btn').addEventListener('click', () => {
          areLineNumbersEnabled = !areLineNumbersEnabled;
          editorInstance.updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
          if (diffEditorInstance) { // Apply to diff editor as well
            diffEditorInstance.getOriginalEditor().updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
            diffEditorInstance.getModifiedEditor().updateOptions({ lineNumbers: areLineNumbersEnabled ? 'on' : 'off' });
          }
          localStorage.setItem('arboEditorLineNumbers', areLineNumbersEnabled);
          document.getElementById('toggle-line-numbers-btn').classList.toggle('active', areLineNumbersEnabled);
          showToast(`Arbo Editor Line Numbers ${areLineNumbersEnabled ? 'Enabled' : 'Disabled'}`, 'info');
        });

        // Toggle Read-Only Mode
        const readOnlyOverlay = document.getElementById('read-only-overlay');
        document.getElementById('read-only-mode-btn').addEventListener('click', () => {
          isReadOnlyMode = !isReadOnlyMode;
          editorInstance.updateOptions({ readOnly: isReadOnlyMode });
          localStorage.setItem('arboEditorReadOnly', isReadOnlyMode);
          document.getElementById('read-only-mode-btn').classList.toggle('active', isReadOnlyMode);
          readOnlyOverlay.classList.toggle('visible', isReadOnlyMode);
          showToast(`Arbo Editor is now ${isReadOnlyMode ? 'Read-Only' : 'Editable'}`, 'info');

          if (diffEditorInstance) {
            // The modified editor in diff view should also respect read-only mode
            diffEditorInstance.getModifiedEditor().updateOptions({ readOnly: isReadOnlyMode });
          }
          updateFormatButtonState(); // Update format button state based on read-only mode
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', async (e) => {
          // Display the pressed key (excluding common modifier keys alone)
          const keyName = e.key;
          if (keyName !== 'Shift' && keyName !== 'Control' && keyName !== 'Alt' && keyName !== 'Meta') {
              showKeyLog(keyName === ' ' ? 'Space' : keyName); // Show "Space" instead of " " for clarity
          }

          // Ctrl/Cmd + S for Save to Cache
          if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault(); // Prevent browser's default save dialog
            const content = editorInstance.getValue();
            await saveToCache(content, true); // Show toast for explicit save
            originalModel.setValue(content); // Sync original model
            lastAutosaveContent = content; // Update last autosaved content
          }
          // Ctrl/Cmd + F for Find (Monaco's built-in)
          // Ctrl/Cmd + Z for Undo (Monaco's built-in)
          // Ctrl/Cmd + Y for Redo (Monaco's built-in)
          // These are already handled by Monaco's default keybindings and the toolbar buttons.
        });
      }

      // --- Initialize Arbo Editor and set up all event listeners ---
      initializeEditor().then(setupEventListeners);
    });
  </script>
</body>
</html>
